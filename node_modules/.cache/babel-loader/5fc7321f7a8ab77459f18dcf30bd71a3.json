{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n\nvar _keys = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/keys\"));\n\nvar _forEach = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/for-each\"));\n\nvar _map = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/map\"));\n\nvar _getIterator2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js/get-iterator\"));\n\nvar _filter = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/filter\"));\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/typeof\"));\n\nvar _slice = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/slice\"));\n\nvar _isArray = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/array/is-array\"));\n\nvar _indexOf = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/index-of\"));\n\nvar equalObjects = require('./equals').default;\n\nvar decode = require('./decode').default;\n\nvar ParseError = require('./ParseError').default;\n\nvar ParsePolygon = require('./ParsePolygon').default;\n\nvar ParseGeoPoint = require('./ParseGeoPoint').default;\n/**\n * contains -- Determines if an object is contained in a list with special handling for Parse pointers.\n */\n\n\nfunction contains(haystack, needle) {\n  if (needle && needle.__type && (needle.__type === 'Pointer' || needle.__type === 'Object')) {\n    for (var i in haystack) {\n      var ptr = haystack[i];\n\n      if (typeof ptr === 'string' && ptr === needle.objectId) {\n        return true;\n      }\n\n      if (ptr.className === needle.className && ptr.objectId === needle.objectId) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  return (0, _indexOf.default)(haystack).call(haystack, needle) > -1;\n}\n\nfunction transformObject(object) {\n  if (object._toFullJSON) {\n    return object._toFullJSON();\n  }\n\n  return object;\n}\n/**\n * matchesQuery -- Determines if an object would be returned by a Parse Query\n * It's a lightweight, where-clause only implementation of a full query engine.\n * Since we find queries that match objects, rather than objects that match\n * queries, we can avoid building a full-blown query tool.\n */\n\n\nfunction matchesQuery(className, object, objects, query) {\n  if (object.className !== className) {\n    return false;\n  }\n\n  var obj = object;\n  var q = query;\n\n  if (object.toJSON) {\n    obj = object.toJSON();\n  }\n\n  if (query.toJSON) {\n    q = query.toJSON().where;\n  }\n\n  obj.className = className;\n\n  for (var field in q) {\n    if (!matchesKeyConstraints(className, obj, objects, field, q[field])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction equalObjectsGeneric(obj, compareTo, eqlFn) {\n  if ((0, _isArray.default)(obj)) {\n    for (var i = 0; i < obj.length; i++) {\n      if (eqlFn(obj[i], compareTo)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  return eqlFn(obj, compareTo);\n}\n/**\n * Determines whether an object matches a single key's constraints\n */\n\n\nfunction matchesKeyConstraints(className, object, objects, key, constraints) {\n  if (constraints === null) {\n    return false;\n  }\n\n  if ((0, _indexOf.default)(key).call(key, '.') >= 0) {\n    // Key references a subobject\n    var keyComponents = key.split('.');\n    var subObjectKey = keyComponents[0];\n    var keyRemainder = (0, _slice.default)(keyComponents).call(keyComponents, 1).join('.');\n    return matchesKeyConstraints(className, object[subObjectKey] || {}, objects, keyRemainder, constraints);\n  }\n\n  var i;\n\n  if (key === '$or') {\n    for (i = 0; i < constraints.length; i++) {\n      if (matchesQuery(className, object, objects, constraints[i])) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  if (key === '$and') {\n    for (i = 0; i < constraints.length; i++) {\n      if (!matchesQuery(className, object, objects, constraints[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  if (key === '$nor') {\n    for (i = 0; i < constraints.length; i++) {\n      if (matchesQuery(className, object, objects, constraints[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  if (key === '$relatedTo') {\n    // Bail! We can't handle relational queries locally\n    return false;\n  }\n\n  if (!/^[A-Za-z][0-9A-Za-z_]*$/.test(key)) {\n    throw new ParseError(ParseError.INVALID_KEY_NAME, \"Invalid Key: \".concat(key));\n  } // Equality (or Array contains) cases\n\n\n  if ((0, _typeof2.default)(constraints) !== 'object') {\n    if ((0, _isArray.default)(object[key])) {\n      var _context;\n\n      return (0, _indexOf.default)(_context = object[key]).call(_context, constraints) > -1;\n    }\n\n    return object[key] === constraints;\n  }\n\n  var compareTo;\n\n  if (constraints.__type) {\n    if (constraints.__type === 'Pointer') {\n      return equalObjectsGeneric(object[key], constraints, function (obj, ptr) {\n        return typeof obj !== 'undefined' && ptr.className === obj.className && ptr.objectId === obj.objectId;\n      });\n    }\n\n    return equalObjectsGeneric(decode(object[key]), decode(constraints), equalObjects);\n  } // More complex cases\n\n\n  for (var condition in constraints) {\n    compareTo = constraints[condition];\n\n    if (compareTo.__type) {\n      compareTo = decode(compareTo);\n    } // Compare Date Object or Date String\n\n\n    if (toString.call(compareTo) === '[object Date]' || typeof compareTo === 'string' && new Date(compareTo) !== 'Invalid Date' && !isNaN(new Date(compareTo))) {\n      object[key] = new Date(object[key].iso ? object[key].iso : object[key]);\n    }\n\n    switch (condition) {\n      case '$lt':\n        if (object[key] >= compareTo) {\n          return false;\n        }\n\n        break;\n\n      case '$lte':\n        if (object[key] > compareTo) {\n          return false;\n        }\n\n        break;\n\n      case '$gt':\n        if (object[key] <= compareTo) {\n          return false;\n        }\n\n        break;\n\n      case '$gte':\n        if (object[key] < compareTo) {\n          return false;\n        }\n\n        break;\n\n      case '$ne':\n        if (equalObjects(object[key], compareTo)) {\n          return false;\n        }\n\n        break;\n\n      case '$in':\n        if (!contains(compareTo, object[key])) {\n          return false;\n        }\n\n        break;\n\n      case '$nin':\n        if (contains(compareTo, object[key])) {\n          return false;\n        }\n\n        break;\n\n      case '$all':\n        for (i = 0; i < compareTo.length; i++) {\n          var _context2;\n\n          if ((0, _indexOf.default)(_context2 = object[key]).call(_context2, compareTo[i]) < 0) {\n            return false;\n          }\n        }\n\n        break;\n\n      case '$exists':\n        {\n          var propertyExists = typeof object[key] !== 'undefined';\n          var existenceIsRequired = constraints['$exists'];\n\n          if (typeof constraints['$exists'] !== 'boolean') {\n            // The SDK will never submit a non-boolean for $exists, but if someone\n            // tries to submit a non-boolean for $exits outside the SDKs, just ignore it.\n            break;\n          }\n\n          if (!propertyExists && existenceIsRequired || propertyExists && !existenceIsRequired) {\n            return false;\n          }\n\n          break;\n        }\n\n      case '$regex':\n        {\n          if ((0, _typeof2.default)(compareTo) === 'object') {\n            return compareTo.test(object[key]);\n          } // JS doesn't support perl-style escaping\n\n\n          var expString = '';\n          var escapeEnd = -2;\n          var escapeStart = (0, _indexOf.default)(compareTo).call(compareTo, '\\\\Q');\n\n          while (escapeStart > -1) {\n            // Add the unescaped portion\n            expString += compareTo.substring(escapeEnd + 2, escapeStart);\n            escapeEnd = (0, _indexOf.default)(compareTo).call(compareTo, '\\\\E', escapeStart);\n\n            if (escapeEnd > -1) {\n              expString += compareTo.substring(escapeStart + 2, escapeEnd).replace(/\\\\\\\\\\\\\\\\E/g, '\\\\E').replace(/\\W/g, '\\\\$&');\n            }\n\n            escapeStart = (0, _indexOf.default)(compareTo).call(compareTo, '\\\\Q', escapeEnd);\n          }\n\n          expString += compareTo.substring(Math.max(escapeStart, escapeEnd + 2));\n          var modifiers = constraints.$options || '';\n          modifiers = modifiers.replace('x', '').replace('s', ''); // Parse Server / Mongo support x and s modifiers but JS RegExp doesn't\n\n          var exp = new RegExp(expString, modifiers);\n\n          if (!exp.test(object[key])) {\n            return false;\n          }\n\n          break;\n        }\n\n      case '$nearSphere':\n        {\n          if (!compareTo || !object[key]) {\n            return false;\n          }\n\n          var distance = compareTo.radiansTo(object[key]);\n          var max = constraints.$maxDistance || Infinity;\n          return distance <= max;\n        }\n\n      case '$within':\n        {\n          if (!compareTo || !object[key]) {\n            return false;\n          }\n\n          var southWest = compareTo.$box[0];\n          var northEast = compareTo.$box[1];\n\n          if (southWest.latitude > northEast.latitude || southWest.longitude > northEast.longitude) {\n            // Invalid box, crosses the date line\n            return false;\n          }\n\n          return object[key].latitude > southWest.latitude && object[key].latitude < northEast.latitude && object[key].longitude > southWest.longitude && object[key].longitude < northEast.longitude;\n        }\n\n      case '$options':\n        // Not a query type, but a way to add options to $regex. Ignore and\n        // avoid the default\n        break;\n\n      case '$maxDistance':\n        // Not a query type, but a way to add a cap to $nearSphere. Ignore and\n        // avoid the default\n        break;\n\n      case '$select':\n        {\n          var subQueryObjects = (0, _filter.default)(objects).call(objects, function (obj, index, arr) {\n            return matchesQuery(compareTo.query.className, obj, arr, compareTo.query.where);\n          });\n\n          for (var _i = 0; _i < subQueryObjects.length; _i += 1) {\n            var subObject = transformObject(subQueryObjects[_i]);\n            return equalObjects(object[key], subObject[compareTo.key]);\n          }\n\n          return false;\n        }\n\n      case '$dontSelect':\n        {\n          var _subQueryObjects = (0, _filter.default)(objects).call(objects, function (obj, index, arr) {\n            return matchesQuery(compareTo.query.className, obj, arr, compareTo.query.where);\n          });\n\n          for (var _i2 = 0; _i2 < _subQueryObjects.length; _i2 += 1) {\n            var _subObject = transformObject(_subQueryObjects[_i2]);\n\n            return !equalObjects(object[key], _subObject[compareTo.key]);\n          }\n\n          return false;\n        }\n\n      case '$inQuery':\n        {\n          var _subQueryObjects2 = (0, _filter.default)(objects).call(objects, function (obj, index, arr) {\n            return matchesQuery(compareTo.className, obj, arr, compareTo.where);\n          });\n\n          for (var _i3 = 0; _i3 < _subQueryObjects2.length; _i3 += 1) {\n            var _subObject2 = transformObject(_subQueryObjects2[_i3]);\n\n            if (object[key].className === _subObject2.className && object[key].objectId === _subObject2.objectId) {\n              return true;\n            }\n          }\n\n          return false;\n        }\n\n      case '$notInQuery':\n        {\n          var _subQueryObjects3 = (0, _filter.default)(objects).call(objects, function (obj, index, arr) {\n            return matchesQuery(compareTo.className, obj, arr, compareTo.where);\n          });\n\n          for (var _i4 = 0; _i4 < _subQueryObjects3.length; _i4 += 1) {\n            var _subObject3 = transformObject(_subQueryObjects3[_i4]);\n\n            if (object[key].className === _subObject3.className && object[key].objectId === _subObject3.objectId) {\n              return false;\n            }\n          }\n\n          return true;\n        }\n\n      case '$containedBy':\n        {\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n\n          try {\n            for (var _iterator = (0, _getIterator2.default)(object[key]), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var value = _step.value;\n\n              if (!contains(compareTo, value)) {\n                return false;\n              }\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return != null) {\n                _iterator.return();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n\n          return true;\n        }\n\n      case '$geoWithin':\n        {\n          var _context3;\n\n          var points = (0, _map.default)(_context3 = compareTo.$polygon).call(_context3, function (geoPoint) {\n            return [geoPoint.latitude, geoPoint.longitude];\n          });\n          var polygon = new ParsePolygon(points);\n          return polygon.containsPoint(object[key]);\n        }\n\n      case '$geoIntersects':\n        {\n          var _polygon = new ParsePolygon(object[key].coordinates);\n\n          var point = new ParseGeoPoint(compareTo.$point);\n          return _polygon.containsPoint(point);\n        }\n\n      default:\n        return false;\n    }\n  }\n\n  return true;\n}\n\nfunction validateQuery(query\n/*: any*/\n) {\n  var _context4;\n\n  var q = query;\n\n  if (query.toJSON) {\n    q = query.toJSON().where;\n  }\n\n  var specialQuerykeys = ['$and', '$or', '$nor', '_rperm', '_wperm', '_perishable_token', '_email_verify_token', '_email_verify_token_expires_at', '_account_lockout_expires_at', '_failed_login_count'];\n  (0, _forEach.default)(_context4 = (0, _keys.default)(q)).call(_context4, function (key) {\n    if (q && q[key] && q[key].$regex) {\n      if (typeof q[key].$options === 'string') {\n        if (!q[key].$options.match(/^[imxs]+$/)) {\n          throw new ParseError(ParseError.INVALID_QUERY, \"Bad $options value for query: \".concat(q[key].$options));\n        }\n      }\n    }\n\n    if ((0, _indexOf.default)(specialQuerykeys).call(specialQuerykeys, key) < 0 && !key.match(/^[a-zA-Z][a-zA-Z0-9_\\.]*$/)) {\n      throw new ParseError(ParseError.INVALID_KEY_NAME, \"Invalid key name: \".concat(key));\n    }\n  });\n}\n\nvar OfflineQuery = {\n  matchesQuery: matchesQuery,\n  validateQuery: validateQuery\n};\nmodule.exports = OfflineQuery;","map":{"version":3,"sources":["/home/roxana/React-Project/datafilter/node_modules/parse/lib/browser/OfflineQuery.js"],"names":["_interopRequireDefault","require","_keys","_forEach","_map","_getIterator2","_filter","_typeof2","_slice","_isArray","_indexOf","equalObjects","default","decode","ParseError","ParsePolygon","ParseGeoPoint","contains","haystack","needle","__type","i","ptr","objectId","className","call","transformObject","object","_toFullJSON","matchesQuery","objects","query","obj","q","toJSON","where","field","matchesKeyConstraints","equalObjectsGeneric","compareTo","eqlFn","length","key","constraints","keyComponents","split","subObjectKey","keyRemainder","join","test","INVALID_KEY_NAME","concat","_context","condition","toString","Date","isNaN","iso","_context2","propertyExists","existenceIsRequired","expString","escapeEnd","escapeStart","substring","replace","Math","max","modifiers","$options","exp","RegExp","distance","radiansTo","$maxDistance","Infinity","southWest","$box","northEast","latitude","longitude","subQueryObjects","index","arr","_i","subObject","_subQueryObjects","_i2","_subObject","_subQueryObjects2","_i3","_subObject2","_subQueryObjects3","_i4","_subObject3","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_iterator","_step","next","done","value","err","return","_context3","points","$polygon","geoPoint","polygon","containsPoint","_polygon","coordinates","point","$point","validateQuery","_context4","specialQuerykeys","$regex","match","INVALID_QUERY","OfflineQuery","module","exports"],"mappings":"AAAA;;AAEA,IAAIA,sBAAsB,GAAGC,OAAO,CAAC,sDAAD,CAApC;;AAEA,IAAIC,KAAK,GAAGF,sBAAsB,CAACC,OAAO,CAAC,mDAAD,CAAR,CAAlC;;AAEA,IAAIE,QAAQ,GAAGH,sBAAsB,CAACC,OAAO,CAAC,yDAAD,CAAR,CAArC;;AAEA,IAAIG,IAAI,GAAGJ,sBAAsB,CAACC,OAAO,CAAC,oDAAD,CAAR,CAAjC;;AAEA,IAAII,aAAa,GAAGL,sBAAsB,CAACC,OAAO,CAAC,6CAAD,CAAR,CAA1C;;AAEA,IAAIK,OAAO,GAAGN,sBAAsB,CAACC,OAAO,CAAC,uDAAD,CAAR,CAApC;;AAEA,IAAIM,QAAQ,GAAGP,sBAAsB,CAACC,OAAO,CAAC,uCAAD,CAAR,CAArC;;AAEA,IAAIO,MAAM,GAAGR,sBAAsB,CAACC,OAAO,CAAC,sDAAD,CAAR,CAAnC;;AAEA,IAAIQ,QAAQ,GAAGT,sBAAsB,CAACC,OAAO,CAAC,sDAAD,CAAR,CAArC;;AAEA,IAAIS,QAAQ,GAAGV,sBAAsB,CAACC,OAAO,CAAC,yDAAD,CAAR,CAArC;;AAEA,IAAIU,YAAY,GAAGV,OAAO,CAAC,UAAD,CAAP,CAAoBW,OAAvC;;AAEA,IAAIC,MAAM,GAAGZ,OAAO,CAAC,UAAD,CAAP,CAAoBW,OAAjC;;AAEA,IAAIE,UAAU,GAAGb,OAAO,CAAC,cAAD,CAAP,CAAwBW,OAAzC;;AAEA,IAAIG,YAAY,GAAGd,OAAO,CAAC,gBAAD,CAAP,CAA0BW,OAA7C;;AAEA,IAAII,aAAa,GAAGf,OAAO,CAAC,iBAAD,CAAP,CAA2BW,OAA/C;AACA;;;;;AAKA,SAASK,QAAT,CAAkBC,QAAlB,EAA4BC,MAA5B,EAAoC;AAClC,MAAIA,MAAM,IAAIA,MAAM,CAACC,MAAjB,KAA4BD,MAAM,CAACC,MAAP,KAAkB,SAAlB,IAA+BD,MAAM,CAACC,MAAP,KAAkB,QAA7E,CAAJ,EAA4F;AAC1F,SAAK,IAAIC,CAAT,IAAcH,QAAd,EAAwB;AACtB,UAAII,GAAG,GAAGJ,QAAQ,CAACG,CAAD,CAAlB;;AAEA,UAAI,OAAOC,GAAP,KAAe,QAAf,IAA2BA,GAAG,KAAKH,MAAM,CAACI,QAA9C,EAAwD;AACtD,eAAO,IAAP;AACD;;AAED,UAAID,GAAG,CAACE,SAAJ,KAAkBL,MAAM,CAACK,SAAzB,IAAsCF,GAAG,CAACC,QAAJ,KAAiBJ,MAAM,CAACI,QAAlE,EAA4E;AAC1E,eAAO,IAAP;AACD;AACF;;AAED,WAAO,KAAP;AACD;;AAED,SAAO,CAAC,GAAGb,QAAQ,CAACE,OAAb,EAAsBM,QAAtB,EAAgCO,IAAhC,CAAqCP,QAArC,EAA+CC,MAA/C,IAAyD,CAAC,CAAjE;AACD;;AAED,SAASO,eAAT,CAAyBC,MAAzB,EAAiC;AAC/B,MAAIA,MAAM,CAACC,WAAX,EAAwB;AACtB,WAAOD,MAAM,CAACC,WAAP,EAAP;AACD;;AAED,SAAOD,MAAP;AACD;AACD;;;;;;;;AAQA,SAASE,YAAT,CAAsBL,SAAtB,EAAiCG,MAAjC,EAAyCG,OAAzC,EAAkDC,KAAlD,EAAyD;AACvD,MAAIJ,MAAM,CAACH,SAAP,KAAqBA,SAAzB,EAAoC;AAClC,WAAO,KAAP;AACD;;AAED,MAAIQ,GAAG,GAAGL,MAAV;AACA,MAAIM,CAAC,GAAGF,KAAR;;AAEA,MAAIJ,MAAM,CAACO,MAAX,EAAmB;AACjBF,IAAAA,GAAG,GAAGL,MAAM,CAACO,MAAP,EAAN;AACD;;AAED,MAAIH,KAAK,CAACG,MAAV,EAAkB;AAChBD,IAAAA,CAAC,GAAGF,KAAK,CAACG,MAAN,GAAeC,KAAnB;AACD;;AAEDH,EAAAA,GAAG,CAACR,SAAJ,GAAgBA,SAAhB;;AAEA,OAAK,IAAIY,KAAT,IAAkBH,CAAlB,EAAqB;AACnB,QAAI,CAACI,qBAAqB,CAACb,SAAD,EAAYQ,GAAZ,EAAiBF,OAAjB,EAA0BM,KAA1B,EAAiCH,CAAC,CAACG,KAAD,CAAlC,CAA1B,EAAsE;AACpE,aAAO,KAAP;AACD;AACF;;AAED,SAAO,IAAP;AACD;;AAED,SAASE,mBAAT,CAA6BN,GAA7B,EAAkCO,SAAlC,EAA6CC,KAA7C,EAAoD;AAClD,MAAI,CAAC,GAAG/B,QAAQ,CAACG,OAAb,EAAsBoB,GAAtB,CAAJ,EAAgC;AAC9B,SAAK,IAAIX,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGW,GAAG,CAACS,MAAxB,EAAgCpB,CAAC,EAAjC,EAAqC;AACnC,UAAImB,KAAK,CAACR,GAAG,CAACX,CAAD,CAAJ,EAASkB,SAAT,CAAT,EAA8B;AAC5B,eAAO,IAAP;AACD;AACF;;AAED,WAAO,KAAP;AACD;;AAED,SAAOC,KAAK,CAACR,GAAD,EAAMO,SAAN,CAAZ;AACD;AACD;;;;;AAKA,SAASF,qBAAT,CAA+Bb,SAA/B,EAA0CG,MAA1C,EAAkDG,OAAlD,EAA2DY,GAA3D,EAAgEC,WAAhE,EAA6E;AAC3E,MAAIA,WAAW,KAAK,IAApB,EAA0B;AACxB,WAAO,KAAP;AACD;;AAED,MAAI,CAAC,GAAGjC,QAAQ,CAACE,OAAb,EAAsB8B,GAAtB,EAA2BjB,IAA3B,CAAgCiB,GAAhC,EAAqC,GAArC,KAA6C,CAAjD,EAAoD;AAClD;AACA,QAAIE,aAAa,GAAGF,GAAG,CAACG,KAAJ,CAAU,GAAV,CAApB;AACA,QAAIC,YAAY,GAAGF,aAAa,CAAC,CAAD,CAAhC;AACA,QAAIG,YAAY,GAAG,CAAC,GAAGvC,MAAM,CAACI,OAAX,EAAoBgC,aAApB,EAAmCnB,IAAnC,CAAwCmB,aAAxC,EAAuD,CAAvD,EAA0DI,IAA1D,CAA+D,GAA/D,CAAnB;AACA,WAAOX,qBAAqB,CAACb,SAAD,EAAYG,MAAM,CAACmB,YAAD,CAAN,IAAwB,EAApC,EAAwChB,OAAxC,EAAiDiB,YAAjD,EAA+DJ,WAA/D,CAA5B;AACD;;AAED,MAAItB,CAAJ;;AAEA,MAAIqB,GAAG,KAAK,KAAZ,EAAmB;AACjB,SAAKrB,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGsB,WAAW,CAACF,MAA5B,EAAoCpB,CAAC,EAArC,EAAyC;AACvC,UAAIQ,YAAY,CAACL,SAAD,EAAYG,MAAZ,EAAoBG,OAApB,EAA6Ba,WAAW,CAACtB,CAAD,CAAxC,CAAhB,EAA8D;AAC5D,eAAO,IAAP;AACD;AACF;;AAED,WAAO,KAAP;AACD;;AAED,MAAIqB,GAAG,KAAK,MAAZ,EAAoB;AAClB,SAAKrB,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGsB,WAAW,CAACF,MAA5B,EAAoCpB,CAAC,EAArC,EAAyC;AACvC,UAAI,CAACQ,YAAY,CAACL,SAAD,EAAYG,MAAZ,EAAoBG,OAApB,EAA6Ba,WAAW,CAACtB,CAAD,CAAxC,CAAjB,EAA+D;AAC7D,eAAO,KAAP;AACD;AACF;;AAED,WAAO,IAAP;AACD;;AAED,MAAIqB,GAAG,KAAK,MAAZ,EAAoB;AAClB,SAAKrB,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGsB,WAAW,CAACF,MAA5B,EAAoCpB,CAAC,EAArC,EAAyC;AACvC,UAAIQ,YAAY,CAACL,SAAD,EAAYG,MAAZ,EAAoBG,OAApB,EAA6Ba,WAAW,CAACtB,CAAD,CAAxC,CAAhB,EAA8D;AAC5D,eAAO,KAAP;AACD;AACF;;AAED,WAAO,IAAP;AACD;;AAED,MAAIqB,GAAG,KAAK,YAAZ,EAA0B;AACxB;AACA,WAAO,KAAP;AACD;;AAED,MAAI,CAAC,0BAA0BO,IAA1B,CAA+BP,GAA/B,CAAL,EAA0C;AACxC,UAAM,IAAI5B,UAAJ,CAAeA,UAAU,CAACoC,gBAA1B,EAA4C,gBAAgBC,MAAhB,CAAuBT,GAAvB,CAA5C,CAAN;AACD,GApD0E,CAoDzE;;;AAGF,MAAI,CAAC,GAAGnC,QAAQ,CAACK,OAAb,EAAsB+B,WAAtB,MAAuC,QAA3C,EAAqD;AACnD,QAAI,CAAC,GAAGlC,QAAQ,CAACG,OAAb,EAAsBe,MAAM,CAACe,GAAD,CAA5B,CAAJ,EAAwC;AACtC,UAAIU,QAAJ;;AAEA,aAAO,CAAC,GAAG1C,QAAQ,CAACE,OAAb,EAAsBwC,QAAQ,GAAGzB,MAAM,CAACe,GAAD,CAAvC,EAA8CjB,IAA9C,CAAmD2B,QAAnD,EAA6DT,WAA7D,IAA4E,CAAC,CAApF;AACD;;AAED,WAAOhB,MAAM,CAACe,GAAD,CAAN,KAAgBC,WAAvB;AACD;;AAED,MAAIJ,SAAJ;;AAEA,MAAII,WAAW,CAACvB,MAAhB,EAAwB;AACtB,QAAIuB,WAAW,CAACvB,MAAZ,KAAuB,SAA3B,EAAsC;AACpC,aAAOkB,mBAAmB,CAACX,MAAM,CAACe,GAAD,CAAP,EAAcC,WAAd,EAA2B,UAAUX,GAAV,EAAeV,GAAf,EAAoB;AACvE,eAAO,OAAOU,GAAP,KAAe,WAAf,IAA8BV,GAAG,CAACE,SAAJ,KAAkBQ,GAAG,CAACR,SAApD,IAAiEF,GAAG,CAACC,QAAJ,KAAiBS,GAAG,CAACT,QAA7F;AACD,OAFyB,CAA1B;AAGD;;AAED,WAAOe,mBAAmB,CAACzB,MAAM,CAACc,MAAM,CAACe,GAAD,CAAP,CAAP,EAAsB7B,MAAM,CAAC8B,WAAD,CAA5B,EAA2ChC,YAA3C,CAA1B;AACD,GA3E0E,CA2EzE;;;AAGF,OAAK,IAAI0C,SAAT,IAAsBV,WAAtB,EAAmC;AACjCJ,IAAAA,SAAS,GAAGI,WAAW,CAACU,SAAD,CAAvB;;AAEA,QAAId,SAAS,CAACnB,MAAd,EAAsB;AACpBmB,MAAAA,SAAS,GAAG1B,MAAM,CAAC0B,SAAD,CAAlB;AACD,KALgC,CAK/B;;;AAGF,QAAIe,QAAQ,CAAC7B,IAAT,CAAcc,SAAd,MAA6B,eAA7B,IAAgD,OAAOA,SAAP,KAAqB,QAArB,IAAiC,IAAIgB,IAAJ,CAAShB,SAAT,MAAwB,cAAzD,IAA2E,CAACiB,KAAK,CAAC,IAAID,IAAJ,CAAShB,SAAT,CAAD,CAArI,EAA4J;AAC1JZ,MAAAA,MAAM,CAACe,GAAD,CAAN,GAAc,IAAIa,IAAJ,CAAS5B,MAAM,CAACe,GAAD,CAAN,CAAYe,GAAZ,GAAkB9B,MAAM,CAACe,GAAD,CAAN,CAAYe,GAA9B,GAAoC9B,MAAM,CAACe,GAAD,CAAnD,CAAd;AACD;;AAED,YAAQW,SAAR;AACE,WAAK,KAAL;AACE,YAAI1B,MAAM,CAACe,GAAD,CAAN,IAAeH,SAAnB,EAA8B;AAC5B,iBAAO,KAAP;AACD;;AAED;;AAEF,WAAK,MAAL;AACE,YAAIZ,MAAM,CAACe,GAAD,CAAN,GAAcH,SAAlB,EAA6B;AAC3B,iBAAO,KAAP;AACD;;AAED;;AAEF,WAAK,KAAL;AACE,YAAIZ,MAAM,CAACe,GAAD,CAAN,IAAeH,SAAnB,EAA8B;AAC5B,iBAAO,KAAP;AACD;;AAED;;AAEF,WAAK,MAAL;AACE,YAAIZ,MAAM,CAACe,GAAD,CAAN,GAAcH,SAAlB,EAA6B;AAC3B,iBAAO,KAAP;AACD;;AAED;;AAEF,WAAK,KAAL;AACE,YAAI5B,YAAY,CAACgB,MAAM,CAACe,GAAD,CAAP,EAAcH,SAAd,CAAhB,EAA0C;AACxC,iBAAO,KAAP;AACD;;AAED;;AAEF,WAAK,KAAL;AACE,YAAI,CAACtB,QAAQ,CAACsB,SAAD,EAAYZ,MAAM,CAACe,GAAD,CAAlB,CAAb,EAAuC;AACrC,iBAAO,KAAP;AACD;;AAED;;AAEF,WAAK,MAAL;AACE,YAAIzB,QAAQ,CAACsB,SAAD,EAAYZ,MAAM,CAACe,GAAD,CAAlB,CAAZ,EAAsC;AACpC,iBAAO,KAAP;AACD;;AAED;;AAEF,WAAK,MAAL;AACE,aAAKrB,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGkB,SAAS,CAACE,MAA1B,EAAkCpB,CAAC,EAAnC,EAAuC;AACrC,cAAIqC,SAAJ;;AAEA,cAAI,CAAC,GAAGhD,QAAQ,CAACE,OAAb,EAAsB8C,SAAS,GAAG/B,MAAM,CAACe,GAAD,CAAxC,EAA+CjB,IAA/C,CAAoDiC,SAApD,EAA+DnB,SAAS,CAAClB,CAAD,CAAxE,IAA+E,CAAnF,EAAsF;AACpF,mBAAO,KAAP;AACD;AACF;;AAED;;AAEF,WAAK,SAAL;AACE;AACE,cAAIsC,cAAc,GAAG,OAAOhC,MAAM,CAACe,GAAD,CAAb,KAAuB,WAA5C;AACA,cAAIkB,mBAAmB,GAAGjB,WAAW,CAAC,SAAD,CAArC;;AAEA,cAAI,OAAOA,WAAW,CAAC,SAAD,CAAlB,KAAkC,SAAtC,EAAiD;AAC/C;AACA;AACA;AACD;;AAED,cAAI,CAACgB,cAAD,IAAmBC,mBAAnB,IAA0CD,cAAc,IAAI,CAACC,mBAAjE,EAAsF;AACpF,mBAAO,KAAP;AACD;;AAED;AACD;;AAEH,WAAK,QAAL;AACE;AACE,cAAI,CAAC,GAAGrD,QAAQ,CAACK,OAAb,EAAsB2B,SAAtB,MAAqC,QAAzC,EAAmD;AACjD,mBAAOA,SAAS,CAACU,IAAV,CAAetB,MAAM,CAACe,GAAD,CAArB,CAAP;AACD,WAHH,CAGI;;;AAGF,cAAImB,SAAS,GAAG,EAAhB;AACA,cAAIC,SAAS,GAAG,CAAC,CAAjB;AACA,cAAIC,WAAW,GAAG,CAAC,GAAGrD,QAAQ,CAACE,OAAb,EAAsB2B,SAAtB,EAAiCd,IAAjC,CAAsCc,SAAtC,EAAiD,KAAjD,CAAlB;;AAEA,iBAAOwB,WAAW,GAAG,CAAC,CAAtB,EAAyB;AACvB;AACAF,YAAAA,SAAS,IAAItB,SAAS,CAACyB,SAAV,CAAoBF,SAAS,GAAG,CAAhC,EAAmCC,WAAnC,CAAb;AACAD,YAAAA,SAAS,GAAG,CAAC,GAAGpD,QAAQ,CAACE,OAAb,EAAsB2B,SAAtB,EAAiCd,IAAjC,CAAsCc,SAAtC,EAAiD,KAAjD,EAAwDwB,WAAxD,CAAZ;;AAEA,gBAAID,SAAS,GAAG,CAAC,CAAjB,EAAoB;AAClBD,cAAAA,SAAS,IAAItB,SAAS,CAACyB,SAAV,CAAoBD,WAAW,GAAG,CAAlC,EAAqCD,SAArC,EAAgDG,OAAhD,CAAwD,YAAxD,EAAsE,KAAtE,EAA6EA,OAA7E,CAAqF,KAArF,EAA4F,MAA5F,CAAb;AACD;;AAEDF,YAAAA,WAAW,GAAG,CAAC,GAAGrD,QAAQ,CAACE,OAAb,EAAsB2B,SAAtB,EAAiCd,IAAjC,CAAsCc,SAAtC,EAAiD,KAAjD,EAAwDuB,SAAxD,CAAd;AACD;;AAEDD,UAAAA,SAAS,IAAItB,SAAS,CAACyB,SAAV,CAAoBE,IAAI,CAACC,GAAL,CAASJ,WAAT,EAAsBD,SAAS,GAAG,CAAlC,CAApB,CAAb;AACA,cAAIM,SAAS,GAAGzB,WAAW,CAAC0B,QAAZ,IAAwB,EAAxC;AACAD,UAAAA,SAAS,GAAGA,SAAS,CAACH,OAAV,CAAkB,GAAlB,EAAuB,EAAvB,EAA2BA,OAA3B,CAAmC,GAAnC,EAAwC,EAAxC,CAAZ,CAxBF,CAwB2D;;AAEzD,cAAIK,GAAG,GAAG,IAAIC,MAAJ,CAAWV,SAAX,EAAsBO,SAAtB,CAAV;;AAEA,cAAI,CAACE,GAAG,CAACrB,IAAJ,CAAStB,MAAM,CAACe,GAAD,CAAf,CAAL,EAA4B;AAC1B,mBAAO,KAAP;AACD;;AAED;AACD;;AAEH,WAAK,aAAL;AACE;AACE,cAAI,CAACH,SAAD,IAAc,CAACZ,MAAM,CAACe,GAAD,CAAzB,EAAgC;AAC9B,mBAAO,KAAP;AACD;;AAED,cAAI8B,QAAQ,GAAGjC,SAAS,CAACkC,SAAV,CAAoB9C,MAAM,CAACe,GAAD,CAA1B,CAAf;AACA,cAAIyB,GAAG,GAAGxB,WAAW,CAAC+B,YAAZ,IAA4BC,QAAtC;AACA,iBAAOH,QAAQ,IAAIL,GAAnB;AACD;;AAEH,WAAK,SAAL;AACE;AACE,cAAI,CAAC5B,SAAD,IAAc,CAACZ,MAAM,CAACe,GAAD,CAAzB,EAAgC;AAC9B,mBAAO,KAAP;AACD;;AAED,cAAIkC,SAAS,GAAGrC,SAAS,CAACsC,IAAV,CAAe,CAAf,CAAhB;AACA,cAAIC,SAAS,GAAGvC,SAAS,CAACsC,IAAV,CAAe,CAAf,CAAhB;;AAEA,cAAID,SAAS,CAACG,QAAV,GAAqBD,SAAS,CAACC,QAA/B,IAA2CH,SAAS,CAACI,SAAV,GAAsBF,SAAS,CAACE,SAA/E,EAA0F;AACxF;AACA,mBAAO,KAAP;AACD;;AAED,iBAAOrD,MAAM,CAACe,GAAD,CAAN,CAAYqC,QAAZ,GAAuBH,SAAS,CAACG,QAAjC,IAA6CpD,MAAM,CAACe,GAAD,CAAN,CAAYqC,QAAZ,GAAuBD,SAAS,CAACC,QAA9E,IAA0FpD,MAAM,CAACe,GAAD,CAAN,CAAYsC,SAAZ,GAAwBJ,SAAS,CAACI,SAA5H,IAAyIrD,MAAM,CAACe,GAAD,CAAN,CAAYsC,SAAZ,GAAwBF,SAAS,CAACE,SAAlL;AACD;;AAEH,WAAK,UAAL;AACE;AACA;AACA;;AAEF,WAAK,cAAL;AACE;AACA;AACA;;AAEF,WAAK,SAAL;AACE;AACE,cAAIC,eAAe,GAAG,CAAC,GAAG3E,OAAO,CAACM,OAAZ,EAAqBkB,OAArB,EAA8BL,IAA9B,CAAmCK,OAAnC,EAA4C,UAAUE,GAAV,EAAekD,KAAf,EAAsBC,GAAtB,EAA2B;AAC3F,mBAAOtD,YAAY,CAACU,SAAS,CAACR,KAAV,CAAgBP,SAAjB,EAA4BQ,GAA5B,EAAiCmD,GAAjC,EAAsC5C,SAAS,CAACR,KAAV,CAAgBI,KAAtD,CAAnB;AACD,WAFqB,CAAtB;;AAIA,eAAK,IAAIiD,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGH,eAAe,CAACxC,MAAtC,EAA8C2C,EAAE,IAAI,CAApD,EAAuD;AACrD,gBAAIC,SAAS,GAAG3D,eAAe,CAACuD,eAAe,CAACG,EAAD,CAAhB,CAA/B;AACA,mBAAOzE,YAAY,CAACgB,MAAM,CAACe,GAAD,CAAP,EAAc2C,SAAS,CAAC9C,SAAS,CAACG,GAAX,CAAvB,CAAnB;AACD;;AAED,iBAAO,KAAP;AACD;;AAEH,WAAK,aAAL;AACE;AACE,cAAI4C,gBAAgB,GAAG,CAAC,GAAGhF,OAAO,CAACM,OAAZ,EAAqBkB,OAArB,EAA8BL,IAA9B,CAAmCK,OAAnC,EAA4C,UAAUE,GAAV,EAAekD,KAAf,EAAsBC,GAAtB,EAA2B;AAC5F,mBAAOtD,YAAY,CAACU,SAAS,CAACR,KAAV,CAAgBP,SAAjB,EAA4BQ,GAA5B,EAAiCmD,GAAjC,EAAsC5C,SAAS,CAACR,KAAV,CAAgBI,KAAtD,CAAnB;AACD,WAFsB,CAAvB;;AAIA,eAAK,IAAIoD,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGD,gBAAgB,CAAC7C,MAAzC,EAAiD8C,GAAG,IAAI,CAAxD,EAA2D;AACzD,gBAAIC,UAAU,GAAG9D,eAAe,CAAC4D,gBAAgB,CAACC,GAAD,CAAjB,CAAhC;;AAEA,mBAAO,CAAC5E,YAAY,CAACgB,MAAM,CAACe,GAAD,CAAP,EAAc8C,UAAU,CAACjD,SAAS,CAACG,GAAX,CAAxB,CAApB;AACD;;AAED,iBAAO,KAAP;AACD;;AAEH,WAAK,UAAL;AACE;AACE,cAAI+C,iBAAiB,GAAG,CAAC,GAAGnF,OAAO,CAACM,OAAZ,EAAqBkB,OAArB,EAA8BL,IAA9B,CAAmCK,OAAnC,EAA4C,UAAUE,GAAV,EAAekD,KAAf,EAAsBC,GAAtB,EAA2B;AAC7F,mBAAOtD,YAAY,CAACU,SAAS,CAACf,SAAX,EAAsBQ,GAAtB,EAA2BmD,GAA3B,EAAgC5C,SAAS,CAACJ,KAA1C,CAAnB;AACD,WAFuB,CAAxB;;AAIA,eAAK,IAAIuD,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGD,iBAAiB,CAAChD,MAA1C,EAAkDiD,GAAG,IAAI,CAAzD,EAA4D;AAC1D,gBAAIC,WAAW,GAAGjE,eAAe,CAAC+D,iBAAiB,CAACC,GAAD,CAAlB,CAAjC;;AAEA,gBAAI/D,MAAM,CAACe,GAAD,CAAN,CAAYlB,SAAZ,KAA0BmE,WAAW,CAACnE,SAAtC,IAAmDG,MAAM,CAACe,GAAD,CAAN,CAAYnB,QAAZ,KAAyBoE,WAAW,CAACpE,QAA5F,EAAsG;AACpG,qBAAO,IAAP;AACD;AACF;;AAED,iBAAO,KAAP;AACD;;AAEH,WAAK,aAAL;AACE;AACE,cAAIqE,iBAAiB,GAAG,CAAC,GAAGtF,OAAO,CAACM,OAAZ,EAAqBkB,OAArB,EAA8BL,IAA9B,CAAmCK,OAAnC,EAA4C,UAAUE,GAAV,EAAekD,KAAf,EAAsBC,GAAtB,EAA2B;AAC7F,mBAAOtD,YAAY,CAACU,SAAS,CAACf,SAAX,EAAsBQ,GAAtB,EAA2BmD,GAA3B,EAAgC5C,SAAS,CAACJ,KAA1C,CAAnB;AACD,WAFuB,CAAxB;;AAIA,eAAK,IAAI0D,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGD,iBAAiB,CAACnD,MAA1C,EAAkDoD,GAAG,IAAI,CAAzD,EAA4D;AAC1D,gBAAIC,WAAW,GAAGpE,eAAe,CAACkE,iBAAiB,CAACC,GAAD,CAAlB,CAAjC;;AAEA,gBAAIlE,MAAM,CAACe,GAAD,CAAN,CAAYlB,SAAZ,KAA0BsE,WAAW,CAACtE,SAAtC,IAAmDG,MAAM,CAACe,GAAD,CAAN,CAAYnB,QAAZ,KAAyBuE,WAAW,CAACvE,QAA5F,EAAsG;AACpG,qBAAO,KAAP;AACD;AACF;;AAED,iBAAO,IAAP;AACD;;AAEH,WAAK,cAAL;AACE;AACE,cAAIwE,yBAAyB,GAAG,IAAhC;AACA,cAAIC,iBAAiB,GAAG,KAAxB;AACA,cAAIC,cAAc,GAAGC,SAArB;;AAEA,cAAI;AACF,iBAAK,IAAIC,SAAS,GAAG,CAAC,GAAG9F,aAAa,CAACO,OAAlB,EAA2Be,MAAM,CAACe,GAAD,CAAjC,CAAhB,EAAyD0D,KAA9D,EAAqE,EAAEL,yBAAyB,GAAG,CAACK,KAAK,GAAGD,SAAS,CAACE,IAAV,EAAT,EAA2BC,IAAzD,CAArE,EAAqIP,yBAAyB,GAAG,IAAjK,EAAuK;AACrK,kBAAIQ,KAAK,GAAGH,KAAK,CAACG,KAAlB;;AAEA,kBAAI,CAACtF,QAAQ,CAACsB,SAAD,EAAYgE,KAAZ,CAAb,EAAiC;AAC/B,uBAAO,KAAP;AACD;AACF;AACF,WARD,CAQE,OAAOC,GAAP,EAAY;AACZR,YAAAA,iBAAiB,GAAG,IAApB;AACAC,YAAAA,cAAc,GAAGO,GAAjB;AACD,WAXD,SAWU;AACR,gBAAI;AACF,kBAAI,CAACT,yBAAD,IAA8BI,SAAS,CAACM,MAAV,IAAoB,IAAtD,EAA4D;AAC1DN,gBAAAA,SAAS,CAACM,MAAV;AACD;AACF,aAJD,SAIU;AACR,kBAAIT,iBAAJ,EAAuB;AACrB,sBAAMC,cAAN;AACD;AACF;AACF;;AAED,iBAAO,IAAP;AACD;;AAEH,WAAK,YAAL;AACE;AACE,cAAIS,SAAJ;;AAEA,cAAIC,MAAM,GAAG,CAAC,GAAGvG,IAAI,CAACQ,OAAT,EAAkB8F,SAAS,GAAGnE,SAAS,CAACqE,QAAxC,EAAkDnF,IAAlD,CAAuDiF,SAAvD,EAAkE,UAAUG,QAAV,EAAoB;AACjG,mBAAO,CAACA,QAAQ,CAAC9B,QAAV,EAAoB8B,QAAQ,CAAC7B,SAA7B,CAAP;AACD,WAFY,CAAb;AAGA,cAAI8B,OAAO,GAAG,IAAI/F,YAAJ,CAAiB4F,MAAjB,CAAd;AACA,iBAAOG,OAAO,CAACC,aAAR,CAAsBpF,MAAM,CAACe,GAAD,CAA5B,CAAP;AACD;;AAEH,WAAK,gBAAL;AACE;AACE,cAAIsE,QAAQ,GAAG,IAAIjG,YAAJ,CAAiBY,MAAM,CAACe,GAAD,CAAN,CAAYuE,WAA7B,CAAf;;AAEA,cAAIC,KAAK,GAAG,IAAIlG,aAAJ,CAAkBuB,SAAS,CAAC4E,MAA5B,CAAZ;AACA,iBAAOH,QAAQ,CAACD,aAAT,CAAuBG,KAAvB,CAAP;AACD;;AAEH;AACE,eAAO,KAAP;AA5QJ;AA8QD;;AAED,SAAO,IAAP;AACD;;AAED,SAASE,aAAT,CAAuBrF;AACvB;AADA,EAEE;AACA,MAAIsF,SAAJ;;AAEA,MAAIpF,CAAC,GAAGF,KAAR;;AAEA,MAAIA,KAAK,CAACG,MAAV,EAAkB;AAChBD,IAAAA,CAAC,GAAGF,KAAK,CAACG,MAAN,GAAeC,KAAnB;AACD;;AAED,MAAImF,gBAAgB,GAAG,CAAC,MAAD,EAAS,KAAT,EAAgB,MAAhB,EAAwB,QAAxB,EAAkC,QAAlC,EAA4C,mBAA5C,EAAiE,qBAAjE,EAAwF,gCAAxF,EAA0H,6BAA1H,EAAyJ,qBAAzJ,CAAvB;AACA,GAAC,GAAGnH,QAAQ,CAACS,OAAb,EAAsByG,SAAS,GAAG,CAAC,GAAGnH,KAAK,CAACU,OAAV,EAAmBqB,CAAnB,CAAlC,EAAyDR,IAAzD,CAA8D4F,SAA9D,EAAyE,UAAU3E,GAAV,EAAe;AACtF,QAAIT,CAAC,IAAIA,CAAC,CAACS,GAAD,CAAN,IAAeT,CAAC,CAACS,GAAD,CAAD,CAAO6E,MAA1B,EAAkC;AAChC,UAAI,OAAOtF,CAAC,CAACS,GAAD,CAAD,CAAO2B,QAAd,KAA2B,QAA/B,EAAyC;AACvC,YAAI,CAACpC,CAAC,CAACS,GAAD,CAAD,CAAO2B,QAAP,CAAgBmD,KAAhB,CAAsB,WAAtB,CAAL,EAAyC;AACvC,gBAAM,IAAI1G,UAAJ,CAAeA,UAAU,CAAC2G,aAA1B,EAAyC,iCAAiCtE,MAAjC,CAAwClB,CAAC,CAACS,GAAD,CAAD,CAAO2B,QAA/C,CAAzC,CAAN;AACD;AACF;AACF;;AAED,QAAI,CAAC,GAAG3D,QAAQ,CAACE,OAAb,EAAsB0G,gBAAtB,EAAwC7F,IAAxC,CAA6C6F,gBAA7C,EAA+D5E,GAA/D,IAAsE,CAAtE,IAA2E,CAACA,GAAG,CAAC8E,KAAJ,CAAU,2BAAV,CAAhF,EAAwH;AACtH,YAAM,IAAI1G,UAAJ,CAAeA,UAAU,CAACoC,gBAA1B,EAA4C,qBAAqBC,MAArB,CAA4BT,GAA5B,CAA5C,CAAN;AACD;AACF,GAZD;AAaD;;AAED,IAAIgF,YAAY,GAAG;AACjB7F,EAAAA,YAAY,EAAEA,YADG;AAEjBuF,EAAAA,aAAa,EAAEA;AAFE,CAAnB;AAIAO,MAAM,CAACC,OAAP,GAAiBF,YAAjB","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n\nvar _keys = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/keys\"));\n\nvar _forEach = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/for-each\"));\n\nvar _map = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/map\"));\n\nvar _getIterator2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js/get-iterator\"));\n\nvar _filter = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/filter\"));\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/typeof\"));\n\nvar _slice = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/slice\"));\n\nvar _isArray = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/array/is-array\"));\n\nvar _indexOf = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/index-of\"));\n\nvar equalObjects = require('./equals').default;\n\nvar decode = require('./decode').default;\n\nvar ParseError = require('./ParseError').default;\n\nvar ParsePolygon = require('./ParsePolygon').default;\n\nvar ParseGeoPoint = require('./ParseGeoPoint').default;\n/**\n * contains -- Determines if an object is contained in a list with special handling for Parse pointers.\n */\n\n\nfunction contains(haystack, needle) {\n  if (needle && needle.__type && (needle.__type === 'Pointer' || needle.__type === 'Object')) {\n    for (var i in haystack) {\n      var ptr = haystack[i];\n\n      if (typeof ptr === 'string' && ptr === needle.objectId) {\n        return true;\n      }\n\n      if (ptr.className === needle.className && ptr.objectId === needle.objectId) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  return (0, _indexOf.default)(haystack).call(haystack, needle) > -1;\n}\n\nfunction transformObject(object) {\n  if (object._toFullJSON) {\n    return object._toFullJSON();\n  }\n\n  return object;\n}\n/**\n * matchesQuery -- Determines if an object would be returned by a Parse Query\n * It's a lightweight, where-clause only implementation of a full query engine.\n * Since we find queries that match objects, rather than objects that match\n * queries, we can avoid building a full-blown query tool.\n */\n\n\nfunction matchesQuery(className, object, objects, query) {\n  if (object.className !== className) {\n    return false;\n  }\n\n  var obj = object;\n  var q = query;\n\n  if (object.toJSON) {\n    obj = object.toJSON();\n  }\n\n  if (query.toJSON) {\n    q = query.toJSON().where;\n  }\n\n  obj.className = className;\n\n  for (var field in q) {\n    if (!matchesKeyConstraints(className, obj, objects, field, q[field])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction equalObjectsGeneric(obj, compareTo, eqlFn) {\n  if ((0, _isArray.default)(obj)) {\n    for (var i = 0; i < obj.length; i++) {\n      if (eqlFn(obj[i], compareTo)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  return eqlFn(obj, compareTo);\n}\n/**\n * Determines whether an object matches a single key's constraints\n */\n\n\nfunction matchesKeyConstraints(className, object, objects, key, constraints) {\n  if (constraints === null) {\n    return false;\n  }\n\n  if ((0, _indexOf.default)(key).call(key, '.') >= 0) {\n    // Key references a subobject\n    var keyComponents = key.split('.');\n    var subObjectKey = keyComponents[0];\n    var keyRemainder = (0, _slice.default)(keyComponents).call(keyComponents, 1).join('.');\n    return matchesKeyConstraints(className, object[subObjectKey] || {}, objects, keyRemainder, constraints);\n  }\n\n  var i;\n\n  if (key === '$or') {\n    for (i = 0; i < constraints.length; i++) {\n      if (matchesQuery(className, object, objects, constraints[i])) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  if (key === '$and') {\n    for (i = 0; i < constraints.length; i++) {\n      if (!matchesQuery(className, object, objects, constraints[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  if (key === '$nor') {\n    for (i = 0; i < constraints.length; i++) {\n      if (matchesQuery(className, object, objects, constraints[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  if (key === '$relatedTo') {\n    // Bail! We can't handle relational queries locally\n    return false;\n  }\n\n  if (!/^[A-Za-z][0-9A-Za-z_]*$/.test(key)) {\n    throw new ParseError(ParseError.INVALID_KEY_NAME, \"Invalid Key: \".concat(key));\n  } // Equality (or Array contains) cases\n\n\n  if ((0, _typeof2.default)(constraints) !== 'object') {\n    if ((0, _isArray.default)(object[key])) {\n      var _context;\n\n      return (0, _indexOf.default)(_context = object[key]).call(_context, constraints) > -1;\n    }\n\n    return object[key] === constraints;\n  }\n\n  var compareTo;\n\n  if (constraints.__type) {\n    if (constraints.__type === 'Pointer') {\n      return equalObjectsGeneric(object[key], constraints, function (obj, ptr) {\n        return typeof obj !== 'undefined' && ptr.className === obj.className && ptr.objectId === obj.objectId;\n      });\n    }\n\n    return equalObjectsGeneric(decode(object[key]), decode(constraints), equalObjects);\n  } // More complex cases\n\n\n  for (var condition in constraints) {\n    compareTo = constraints[condition];\n\n    if (compareTo.__type) {\n      compareTo = decode(compareTo);\n    } // Compare Date Object or Date String\n\n\n    if (toString.call(compareTo) === '[object Date]' || typeof compareTo === 'string' && new Date(compareTo) !== 'Invalid Date' && !isNaN(new Date(compareTo))) {\n      object[key] = new Date(object[key].iso ? object[key].iso : object[key]);\n    }\n\n    switch (condition) {\n      case '$lt':\n        if (object[key] >= compareTo) {\n          return false;\n        }\n\n        break;\n\n      case '$lte':\n        if (object[key] > compareTo) {\n          return false;\n        }\n\n        break;\n\n      case '$gt':\n        if (object[key] <= compareTo) {\n          return false;\n        }\n\n        break;\n\n      case '$gte':\n        if (object[key] < compareTo) {\n          return false;\n        }\n\n        break;\n\n      case '$ne':\n        if (equalObjects(object[key], compareTo)) {\n          return false;\n        }\n\n        break;\n\n      case '$in':\n        if (!contains(compareTo, object[key])) {\n          return false;\n        }\n\n        break;\n\n      case '$nin':\n        if (contains(compareTo, object[key])) {\n          return false;\n        }\n\n        break;\n\n      case '$all':\n        for (i = 0; i < compareTo.length; i++) {\n          var _context2;\n\n          if ((0, _indexOf.default)(_context2 = object[key]).call(_context2, compareTo[i]) < 0) {\n            return false;\n          }\n        }\n\n        break;\n\n      case '$exists':\n        {\n          var propertyExists = typeof object[key] !== 'undefined';\n          var existenceIsRequired = constraints['$exists'];\n\n          if (typeof constraints['$exists'] !== 'boolean') {\n            // The SDK will never submit a non-boolean for $exists, but if someone\n            // tries to submit a non-boolean for $exits outside the SDKs, just ignore it.\n            break;\n          }\n\n          if (!propertyExists && existenceIsRequired || propertyExists && !existenceIsRequired) {\n            return false;\n          }\n\n          break;\n        }\n\n      case '$regex':\n        {\n          if ((0, _typeof2.default)(compareTo) === 'object') {\n            return compareTo.test(object[key]);\n          } // JS doesn't support perl-style escaping\n\n\n          var expString = '';\n          var escapeEnd = -2;\n          var escapeStart = (0, _indexOf.default)(compareTo).call(compareTo, '\\\\Q');\n\n          while (escapeStart > -1) {\n            // Add the unescaped portion\n            expString += compareTo.substring(escapeEnd + 2, escapeStart);\n            escapeEnd = (0, _indexOf.default)(compareTo).call(compareTo, '\\\\E', escapeStart);\n\n            if (escapeEnd > -1) {\n              expString += compareTo.substring(escapeStart + 2, escapeEnd).replace(/\\\\\\\\\\\\\\\\E/g, '\\\\E').replace(/\\W/g, '\\\\$&');\n            }\n\n            escapeStart = (0, _indexOf.default)(compareTo).call(compareTo, '\\\\Q', escapeEnd);\n          }\n\n          expString += compareTo.substring(Math.max(escapeStart, escapeEnd + 2));\n          var modifiers = constraints.$options || '';\n          modifiers = modifiers.replace('x', '').replace('s', ''); // Parse Server / Mongo support x and s modifiers but JS RegExp doesn't\n\n          var exp = new RegExp(expString, modifiers);\n\n          if (!exp.test(object[key])) {\n            return false;\n          }\n\n          break;\n        }\n\n      case '$nearSphere':\n        {\n          if (!compareTo || !object[key]) {\n            return false;\n          }\n\n          var distance = compareTo.radiansTo(object[key]);\n          var max = constraints.$maxDistance || Infinity;\n          return distance <= max;\n        }\n\n      case '$within':\n        {\n          if (!compareTo || !object[key]) {\n            return false;\n          }\n\n          var southWest = compareTo.$box[0];\n          var northEast = compareTo.$box[1];\n\n          if (southWest.latitude > northEast.latitude || southWest.longitude > northEast.longitude) {\n            // Invalid box, crosses the date line\n            return false;\n          }\n\n          return object[key].latitude > southWest.latitude && object[key].latitude < northEast.latitude && object[key].longitude > southWest.longitude && object[key].longitude < northEast.longitude;\n        }\n\n      case '$options':\n        // Not a query type, but a way to add options to $regex. Ignore and\n        // avoid the default\n        break;\n\n      case '$maxDistance':\n        // Not a query type, but a way to add a cap to $nearSphere. Ignore and\n        // avoid the default\n        break;\n\n      case '$select':\n        {\n          var subQueryObjects = (0, _filter.default)(objects).call(objects, function (obj, index, arr) {\n            return matchesQuery(compareTo.query.className, obj, arr, compareTo.query.where);\n          });\n\n          for (var _i = 0; _i < subQueryObjects.length; _i += 1) {\n            var subObject = transformObject(subQueryObjects[_i]);\n            return equalObjects(object[key], subObject[compareTo.key]);\n          }\n\n          return false;\n        }\n\n      case '$dontSelect':\n        {\n          var _subQueryObjects = (0, _filter.default)(objects).call(objects, function (obj, index, arr) {\n            return matchesQuery(compareTo.query.className, obj, arr, compareTo.query.where);\n          });\n\n          for (var _i2 = 0; _i2 < _subQueryObjects.length; _i2 += 1) {\n            var _subObject = transformObject(_subQueryObjects[_i2]);\n\n            return !equalObjects(object[key], _subObject[compareTo.key]);\n          }\n\n          return false;\n        }\n\n      case '$inQuery':\n        {\n          var _subQueryObjects2 = (0, _filter.default)(objects).call(objects, function (obj, index, arr) {\n            return matchesQuery(compareTo.className, obj, arr, compareTo.where);\n          });\n\n          for (var _i3 = 0; _i3 < _subQueryObjects2.length; _i3 += 1) {\n            var _subObject2 = transformObject(_subQueryObjects2[_i3]);\n\n            if (object[key].className === _subObject2.className && object[key].objectId === _subObject2.objectId) {\n              return true;\n            }\n          }\n\n          return false;\n        }\n\n      case '$notInQuery':\n        {\n          var _subQueryObjects3 = (0, _filter.default)(objects).call(objects, function (obj, index, arr) {\n            return matchesQuery(compareTo.className, obj, arr, compareTo.where);\n          });\n\n          for (var _i4 = 0; _i4 < _subQueryObjects3.length; _i4 += 1) {\n            var _subObject3 = transformObject(_subQueryObjects3[_i4]);\n\n            if (object[key].className === _subObject3.className && object[key].objectId === _subObject3.objectId) {\n              return false;\n            }\n          }\n\n          return true;\n        }\n\n      case '$containedBy':\n        {\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n\n          try {\n            for (var _iterator = (0, _getIterator2.default)(object[key]), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var value = _step.value;\n\n              if (!contains(compareTo, value)) {\n                return false;\n              }\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return != null) {\n                _iterator.return();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n\n          return true;\n        }\n\n      case '$geoWithin':\n        {\n          var _context3;\n\n          var points = (0, _map.default)(_context3 = compareTo.$polygon).call(_context3, function (geoPoint) {\n            return [geoPoint.latitude, geoPoint.longitude];\n          });\n          var polygon = new ParsePolygon(points);\n          return polygon.containsPoint(object[key]);\n        }\n\n      case '$geoIntersects':\n        {\n          var _polygon = new ParsePolygon(object[key].coordinates);\n\n          var point = new ParseGeoPoint(compareTo.$point);\n          return _polygon.containsPoint(point);\n        }\n\n      default:\n        return false;\n    }\n  }\n\n  return true;\n}\n\nfunction validateQuery(query\n/*: any*/\n) {\n  var _context4;\n\n  var q = query;\n\n  if (query.toJSON) {\n    q = query.toJSON().where;\n  }\n\n  var specialQuerykeys = ['$and', '$or', '$nor', '_rperm', '_wperm', '_perishable_token', '_email_verify_token', '_email_verify_token_expires_at', '_account_lockout_expires_at', '_failed_login_count'];\n  (0, _forEach.default)(_context4 = (0, _keys.default)(q)).call(_context4, function (key) {\n    if (q && q[key] && q[key].$regex) {\n      if (typeof q[key].$options === 'string') {\n        if (!q[key].$options.match(/^[imxs]+$/)) {\n          throw new ParseError(ParseError.INVALID_QUERY, \"Bad $options value for query: \".concat(q[key].$options));\n        }\n      }\n    }\n\n    if ((0, _indexOf.default)(specialQuerykeys).call(specialQuerykeys, key) < 0 && !key.match(/^[a-zA-Z][a-zA-Z0-9_\\.]*$/)) {\n      throw new ParseError(ParseError.INVALID_KEY_NAME, \"Invalid key name: \".concat(key));\n    }\n  });\n}\n\nvar OfflineQuery = {\n  matchesQuery: matchesQuery,\n  validateQuery: validateQuery\n};\nmodule.exports = OfflineQuery;"]},"metadata":{},"sourceType":"script"}