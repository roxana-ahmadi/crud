{"ast":null,"code":"import Parse from 'parse';\nimport { Record } from 'immutable';\nimport { withState, withHandlers, pipe } from '../../util';\nconst ClouseQuery = Parse.Object.extend('ClouseQuery');\n\nconst init = props => props.filterData;\n\nconst addClouse = ({\n  setData,\n  data\n}) => () => {\n  const query = new Parse.Query(ClouseQuery);\n  setData(data => data.childs = data.childs.concat(query));\n};\n\nconst deleteChild = ({\n  setData\n}) => index => {\n  setData(d => d.set('childs', d.childs.filter((value, i) => i !== index)));\n};\n\nconst changeOprand = ({\n  setData\n}) => oprand => {\n  setData(d => d.set('op', oprand));\n};\n\nconst addOprand = ({\n  setData\n}) => () => {\n  const query = new Parse.Query(ClouseQuery);\n  setData(d => d.set('childs', d.childs.concat(Record({\n    op: 'and',\n    childs: [],\n    mainQuery: query\n  })())));\n};\n\nlet mainQuery = new Parse.Query(ClouseQuery);\n\nconst makeMainQuery = data => {\n  console.log('maake main query start', mainQuery);\n  console.log(data.mainQuery);\n\n  if (data.childs) {\n    const {\n      op\n    } = data;\n    data.childs.map(x => {\n      if (op === 'and') {\n        mainQuery = Parse.Query.and(mainQuery, makeMainQuery(x));\n      }\n\n      if (op === 'or') {\n        console.log('op', data.op);\n        mainQuery = Parse.Query.or(mainQuery, makeMainQuery(x));\n      }\n\n      if (!x.op) {\n        if (op === 'and') {\n          console.log('op', op);\n          mainQuery = Parse.Query.and(mainQuery, x);\n        } else {\n          mainQuery = Parse.Query.or(mainQuery, x);\n        }\n      }\n\n      return makeMainQuery(x);\n    });\n  } else {\n    console.log('nochilds');\n    return data;\n  }\n};\n\nconst recursiveFunc = () => n => {\n  makeMainQuery(n);\n};\n\nconst oprandController = pipe(withState(init), withHandlers({\n  addClouse,\n  deleteChild,\n  changeOprand,\n  addOprand,\n  makeMainQuery,\n  recursiveFunc\n}));\nexport default oprandController;","map":{"version":3,"sources":["/home/roxana/React-Project/datafilter/src/components/oprand/oprandController.js"],"names":["Parse","Record","withState","withHandlers","pipe","ClouseQuery","Object","extend","init","props","filterData","addClouse","setData","data","query","Query","childs","concat","deleteChild","index","d","set","filter","value","i","changeOprand","oprand","addOprand","op","mainQuery","makeMainQuery","console","log","map","x","and","or","recursiveFunc","n","oprandController"],"mappings":"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","sourcesContent":["\nimport Parse from 'parse';\nimport {\n  Record,\n} from 'immutable';\nimport {\n  withState, withHandlers, pipe,\n} from '../../util';\n\n\nconst ClouseQuery = Parse.Object.extend('ClouseQuery');\n\nconst init = (props) => props.filterData;\n\nconst addClouse = ({ setData, data }) => () => {\n  const query = new Parse.Query(ClouseQuery);\n\n  setData((data) => (data.childs = data.childs.concat(query)));\n};\n\nconst deleteChild = ({ setData }) => (index) => {\n  setData((d) => d.set('childs', d.childs.filter((value, i) => i !== index)));\n};\n\nconst changeOprand = ({ setData }) => (oprand) => {\n  setData((d) => d.set('op', oprand));\n};\n\nconst addOprand = ({ setData }) => () => {\n  const query = new Parse.Query(ClouseQuery);\n  setData((d) => d.set('childs', d.childs.concat(Record({ op: 'and', childs: [], mainQuery: query })())));\n};\n\nlet mainQuery = new Parse.Query(ClouseQuery);\n\nconst makeMainQuery = (data) => {\n  console.log('maake main query start', mainQuery);\n  console.log(data.mainQuery);\n\n  if (data.childs) {\n    const { op } = data;\n    data.childs.map((x) => {\n      if (op === 'and') {\n        mainQuery = Parse.Query.and(mainQuery, makeMainQuery(x));\n      }\n      if (op === 'or') {\n        console.log('op', data.op);\n        mainQuery = Parse.Query.or(mainQuery, makeMainQuery(x));\n      }\n      if (!x.op) {\n        if (op === 'and') {\n          console.log('op', op);\n          mainQuery = Parse.Query.and(mainQuery, x);\n        } else {\n          mainQuery = Parse.Query.or(mainQuery, x);\n        }\n      }\n      return makeMainQuery(x);\n    });\n  } else {\n    console.log('nochilds');\n    return data;\n  }\n};\n\n\nconst recursiveFunc = () => (n) => {\n  makeMainQuery(n);\n};\n\nconst oprandController = pipe(\n  withState(init),\n  withHandlers({\n    addClouse,\n    deleteChild,\n    changeOprand,\n    addOprand,\n    makeMainQuery,\n    recursiveFunc,\n  }),\n);\n\nexport default oprandController;\n"]},"metadata":{},"sourceType":"module"}