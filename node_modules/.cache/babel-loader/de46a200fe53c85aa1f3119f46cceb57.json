{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _indexOf = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/index-of\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/defineProperty\"));\n\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\n\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n\nvar FIELD_TYPES = ['String', 'Number', 'Boolean', 'Date', 'File', 'GeoPoint', 'Polygon', 'Array', 'Object', 'Pointer', 'Relation'];\n/*:: type FieldOptions = {\n  required: boolean;\n  defaultValue: mixed;\n};*/\n\n/**\n * A Parse.Schema object is for handling schema data from Parse.\n * <p>All the schemas methods require MasterKey.\n *\n * When adding fields, you may set required and default values. (Requires Parse Server 3.7.0+)\n *\n * <pre>\n * const options = { required: true, defaultValue: 'hello world' };\n * const schema = new Parse.Schema('MyClass');\n * schema.addString('field', options);\n * schema.addIndex('index_name', { 'field': 1 });\n * schema.save();\n * </pre>\n * </p>\n * @alias Parse.Schema\n */\n\nvar ParseSchema =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param {String} className Parse Class string.\n   */\n  function ParseSchema(className\n  /*: string*/\n  ) {\n    (0, _classCallCheck2.default)(this, ParseSchema);\n    (0, _defineProperty2.default)(this, \"className\", void 0);\n    (0, _defineProperty2.default)(this, \"_fields\", void 0);\n    (0, _defineProperty2.default)(this, \"_indexes\", void 0);\n    (0, _defineProperty2.default)(this, \"_clp\", void 0);\n\n    if (typeof className === 'string') {\n      if (className === 'User' && _CoreManager.default.get('PERFORM_USER_REWRITE')) {\n        this.className = '_User';\n      } else {\n        this.className = className;\n      }\n    }\n\n    this._fields = {};\n    this._indexes = {};\n  }\n  /**\n   * Static method to get all schemas\n   *\n   * @return {Promise} A promise that is resolved with the result when\n   * the query completes.\n   */\n\n\n  (0, _createClass2.default)(ParseSchema, [{\n    key: \"get\",\n\n    /**\n     * Get the Schema from Parse\n     *\n     * @return {Promise} A promise that is resolved with the result when\n     * the query completes.\n     */\n    value: function () {\n      this.assertClassName();\n\n      var controller = _CoreManager.default.getSchemaController();\n\n      return controller.get(this.className).then(function (response) {\n        if (!response) {\n          throw new Error('Schema not found.');\n        }\n\n        return response;\n      });\n    }\n    /**\n     * Create a new Schema on Parse\n     *\n     * @return {Promise} A promise that is resolved with the result when\n     * the query completes.\n     */\n\n  }, {\n    key: \"save\",\n    value: function () {\n      this.assertClassName();\n\n      var controller = _CoreManager.default.getSchemaController();\n\n      var params = {\n        className: this.className,\n        fields: this._fields,\n        indexes: this._indexes,\n        classLevelPermissions: this._clp\n      };\n      return controller.create(this.className, params);\n    }\n    /**\n     * Update a Schema on Parse\n     *\n     * @return {Promise} A promise that is resolved with the result when\n     * the query completes.\n     */\n\n  }, {\n    key: \"update\",\n    value: function () {\n      this.assertClassName();\n\n      var controller = _CoreManager.default.getSchemaController();\n\n      var params = {\n        className: this.className,\n        fields: this._fields,\n        indexes: this._indexes,\n        classLevelPermissions: this._clp\n      };\n      this._fields = {};\n      this._indexes = {};\n      return controller.update(this.className, params);\n    }\n    /**\n     * Removing a Schema from Parse\n     * Can only be used on Schema without objects\n     *\n     * @return {Promise} A promise that is resolved with the result when\n     * the query completes.\n     */\n\n  }, {\n    key: \"delete\",\n    value: function () {\n      this.assertClassName();\n\n      var controller = _CoreManager.default.getSchemaController();\n\n      return controller.delete(this.className);\n    }\n    /**\n     * Removes all objects from a Schema (class) in Parse.\n     * EXERCISE CAUTION, running this will delete all objects for this schema and cannot be reversed\n     * @return {Promise} A promise that is resolved with the result when\n     * the query completes.\n     */\n\n  }, {\n    key: \"purge\",\n    value: function () {\n      this.assertClassName();\n\n      var controller = _CoreManager.default.getSchemaController();\n\n      return controller.purge(this.className);\n    }\n    /**\n     * Assert if ClassName has been filled\n     * @private\n     */\n\n  }, {\n    key: \"assertClassName\",\n    value: function () {\n      if (!this.className) {\n        throw new Error('You must set a Class Name before making any request.');\n      }\n    }\n    /**\n     * Sets Class Level Permissions when creating / updating a Schema.\n     * EXERCISE CAUTION, running this may override CLP for this schema and cannot be reversed\n     *\n     * @param {Object} clp Class Level Permissions\n     * @return {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"setCLP\",\n    value: function (clp\n    /*: { [key: string]: mixed }*/\n    ) {\n      this._clp = clp;\n      return this;\n    }\n    /**\n     * Adding a Field to Create / Update a Schema\n     *\n     * @param {String} name Name of the field that will be created on Parse\n     * @param {String} type Can be a (String|Number|Boolean|Date|Parse.File|Parse.GeoPoint|Array|Object|Pointer|Parse.Relation)\n     * @param {Object} options\n     * Valid options are:<ul>\n     *   <li>required: If field is not set, save operation fails (Requires Parse Server 3.7.0+)\n     *   <li>defaultValue: If field is not set, a default value is selected (Requires Parse Server 3.7.0+)\n     * </ul>\n     * @return {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"addField\",\n    value: function (name\n    /*: string*/\n    , type\n    /*: string*/\n    ) {\n      var options\n      /*: FieldOptions*/\n      = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      type = type || 'String';\n\n      if (!name) {\n        throw new Error('field name may not be null.');\n      }\n\n      if ((0, _indexOf.default)(FIELD_TYPES).call(FIELD_TYPES, type) === -1) {\n        throw new Error(\"\".concat(type, \" is not a valid type.\"));\n      }\n\n      var fieldOptions = {\n        type: type\n      };\n\n      if (typeof options.required === 'boolean') {\n        fieldOptions.required = options.required;\n      }\n\n      if (options.defaultValue !== undefined) {\n        fieldOptions.defaultValue = options.defaultValue;\n      }\n\n      this._fields[name] = fieldOptions;\n      return this;\n    }\n    /**\n     * Adding an Index to Create / Update a Schema\n     *\n     * @param {String} name Name of the field that will be created on Parse\n     * @param {String} type Can be a (String|Number|Boolean|Date|Parse.File|Parse.GeoPoint|Array|Object|Pointer|Parse.Relation)\n     * @return {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"addIndex\",\n    value: function (name\n    /*: string*/\n    , index\n    /*: any*/\n    ) {\n      if (!name) {\n        throw new Error('index name may not be null.');\n      }\n\n      if (!index) {\n        throw new Error('index may not be null.');\n      }\n\n      this._indexes[name] = index;\n      return this;\n    }\n    /**\n     * Adding String Field\n     *\n     * @param {String} name Name of the field that will be created on Parse\n     * @param {Object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n     * @return {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"addString\",\n    value: function (name\n    /*: string*/\n    , options\n    /*: FieldOptions*/\n    ) {\n      return this.addField(name, 'String', options);\n    }\n    /**\n     * Adding Number Field\n     *\n     * @param {String} name Name of the field that will be created on Parse\n     * @param {Object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n     * @return {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"addNumber\",\n    value: function (name\n    /*: string*/\n    , options\n    /*: FieldOptions*/\n    ) {\n      return this.addField(name, 'Number', options);\n    }\n    /**\n     * Adding Boolean Field\n     *\n     * @param {String} name Name of the field that will be created on Parse\n     * @param {Object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n     * @return {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"addBoolean\",\n    value: function (name\n    /*: string*/\n    , options\n    /*: FieldOptions*/\n    ) {\n      return this.addField(name, 'Boolean', options);\n    }\n    /**\n     * Adding Date Field\n     *\n     * @param {String} name Name of the field that will be created on Parse\n     * @param {Object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n     * @return {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"addDate\",\n    value: function (name\n    /*: string*/\n    , options\n    /*: FieldOptions*/\n    ) {\n      if (options && options.defaultValue) {\n        options.defaultValue = {\n          __type: 'Date',\n          iso: new Date(options.defaultValue)\n        };\n      }\n\n      return this.addField(name, 'Date', options);\n    }\n    /**\n     * Adding File Field\n     *\n     * @param {String} name Name of the field that will be created on Parse\n     * @param {Object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n     * @return {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"addFile\",\n    value: function (name\n    /*: string*/\n    , options\n    /*: FieldOptions*/\n    ) {\n      return this.addField(name, 'File', options);\n    }\n    /**\n     * Adding GeoPoint Field\n     *\n     * @param {String} name Name of the field that will be created on Parse\n     * @param {Object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n     * @return {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"addGeoPoint\",\n    value: function (name\n    /*: string*/\n    , options\n    /*: FieldOptions*/\n    ) {\n      return this.addField(name, 'GeoPoint', options);\n    }\n    /**\n     * Adding Polygon Field\n     *\n     * @param {String} name Name of the field that will be created on Parse\n     * @param {Object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n     * @return {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"addPolygon\",\n    value: function (name\n    /*: string*/\n    , options\n    /*: FieldOptions*/\n    ) {\n      return this.addField(name, 'Polygon', options);\n    }\n    /**\n     * Adding Array Field\n     *\n     * @param {String} name Name of the field that will be created on Parse\n     * @param {Object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n     * @return {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"addArray\",\n    value: function (name\n    /*: string*/\n    , options\n    /*: FieldOptions*/\n    ) {\n      return this.addField(name, 'Array', options);\n    }\n    /**\n     * Adding Object Field\n     *\n     * @param {String} name Name of the field that will be created on Parse\n     * @param {Object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n     * @return {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"addObject\",\n    value: function (name\n    /*: string*/\n    , options\n    /*: FieldOptions*/\n    ) {\n      return this.addField(name, 'Object', options);\n    }\n    /**\n     * Adding Pointer Field\n     *\n     * @param {String} name Name of the field that will be created on Parse\n     * @param {String} targetClass Name of the target Pointer Class\n     * @param {Object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n     * @return {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"addPointer\",\n    value: function (name\n    /*: string*/\n    , targetClass\n    /*: string*/\n    ) {\n      var options\n      /*: FieldOptions*/\n      = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      if (!name) {\n        throw new Error('field name may not be null.');\n      }\n\n      if (!targetClass) {\n        throw new Error('You need to set the targetClass of the Pointer.');\n      }\n\n      var fieldOptions = {\n        type: 'Pointer',\n        targetClass: targetClass\n      };\n\n      if (typeof options.required === 'boolean') {\n        fieldOptions.required = options.required;\n      }\n\n      if (options.defaultValue !== undefined) {\n        fieldOptions.defaultValue = options.defaultValue;\n\n        if (options.defaultValue instanceof _ParseObject.default) {\n          fieldOptions.defaultValue = options.defaultValue.toPointer();\n        }\n      }\n\n      this._fields[name] = fieldOptions;\n      return this;\n    }\n    /**\n     * Adding Relation Field\n     *\n     * @param {String} name Name of the field that will be created on Parse\n     * @param {String} targetClass Name of the target Pointer Class\n     * @return {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"addRelation\",\n    value: function (name\n    /*: string*/\n    , targetClass\n    /*: string*/\n    ) {\n      if (!name) {\n        throw new Error('field name may not be null.');\n      }\n\n      if (!targetClass) {\n        throw new Error('You need to set the targetClass of the Relation.');\n      }\n\n      this._fields[name] = {\n        type: 'Relation',\n        targetClass: targetClass\n      };\n      return this;\n    }\n    /**\n     * Deleting a Field to Update on a Schema\n     *\n     * @param {String} name Name of the field\n     * @return {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"deleteField\",\n    value: function (name\n    /*: string*/\n    ) {\n      this._fields[name] = {\n        __op: 'Delete'\n      };\n      return this;\n    }\n    /**\n     * Deleting an Index to Update on a Schema\n     *\n     * @param {String} name Name of the field\n     * @return {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"deleteIndex\",\n    value: function (name\n    /*: string*/\n    ) {\n      this._indexes[name] = {\n        __op: 'Delete'\n      };\n      return this;\n    }\n  }], [{\n    key: \"all\",\n    value: function () {\n      var controller = _CoreManager.default.getSchemaController();\n\n      return controller.get('').then(function (response) {\n        if (response.results.length === 0) {\n          throw new Error('Schema not found.');\n        }\n\n        return response.results;\n      });\n    }\n  }]);\n  return ParseSchema;\n}();\n\nvar DefaultController = {\n  send: function (className\n  /*: string*/\n  , method\n  /*: string*/\n  )\n  /*: Promise*/\n  {\n    var params\n    /*: any*/\n    = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    var RESTController = _CoreManager.default.getRESTController();\n\n    return RESTController.request(method, \"schemas/\".concat(className), params, {\n      useMasterKey: true\n    });\n  },\n  get: function (className\n  /*: string*/\n  )\n  /*: Promise*/\n  {\n    return this.send(className, 'GET');\n  },\n  create: function (className\n  /*: string*/\n  , params\n  /*: any*/\n  )\n  /*: Promise*/\n  {\n    return this.send(className, 'POST', params);\n  },\n  update: function (className\n  /*: string*/\n  , params\n  /*: any*/\n  )\n  /*: Promise*/\n  {\n    return this.send(className, 'PUT', params);\n  },\n  delete: function (className\n  /*: string*/\n  )\n  /*: Promise*/\n  {\n    return this.send(className, 'DELETE');\n  },\n  purge: function (className\n  /*: string*/\n  )\n  /*: Promise*/\n  {\n    var RESTController = _CoreManager.default.getRESTController();\n\n    return RESTController.request('DELETE', \"purge/\".concat(className), {}, {\n      useMasterKey: true\n    });\n  }\n};\n\n_CoreManager.default.setSchemaController(DefaultController);\n\nvar _default = ParseSchema;\nexports.default = _default;","map":{"version":3,"sources":["/home/roxana/React-Project/datafilter/node_modules/parse/lib/browser/ParseSchema.js"],"names":["_interopRequireDefault","require","_Object$defineProperty","exports","value","default","_indexOf","_classCallCheck2","_createClass2","_defineProperty2","_CoreManager","_ParseObject","FIELD_TYPES","ParseSchema","className","get","_fields","_indexes","key","assertClassName","controller","getSchemaController","then","response","Error","params","fields","indexes","classLevelPermissions","_clp","create","update","delete","purge","clp","name","type","options","arguments","length","undefined","call","concat","fieldOptions","required","defaultValue","index","addField","__type","iso","Date","targetClass","toPointer","__op","results","DefaultController","send","method","RESTController","getRESTController","request","useMasterKey","setSchemaController","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = void 0;\n\nvar _indexOf = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/index-of\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/defineProperty\"));\n\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\n\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n\nvar FIELD_TYPES = ['String', 'Number', 'Boolean', 'Date', 'File', 'GeoPoint', 'Polygon', 'Array', 'Object', 'Pointer', 'Relation'];\n/*:: type FieldOptions = {\n  required: boolean;\n  defaultValue: mixed;\n};*/\n\n/**\n * A Parse.Schema object is for handling schema data from Parse.\n * <p>All the schemas methods require MasterKey.\n *\n * When adding fields, you may set required and default values. (Requires Parse Server 3.7.0+)\n *\n * <pre>\n * const options = { required: true, defaultValue: 'hello world' };\n * const schema = new Parse.Schema('MyClass');\n * schema.addString('field', options);\n * schema.addIndex('index_name', { 'field': 1 });\n * schema.save();\n * </pre>\n * </p>\n * @alias Parse.Schema\n */\n\nvar ParseSchema =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param {String} className Parse Class string.\n   */\n  function ParseSchema(className\n  /*: string*/\n  ) {\n    (0, _classCallCheck2.default)(this, ParseSchema);\n    (0, _defineProperty2.default)(this, \"className\", void 0);\n    (0, _defineProperty2.default)(this, \"_fields\", void 0);\n    (0, _defineProperty2.default)(this, \"_indexes\", void 0);\n    (0, _defineProperty2.default)(this, \"_clp\", void 0);\n\n    if (typeof className === 'string') {\n      if (className === 'User' && _CoreManager.default.get('PERFORM_USER_REWRITE')) {\n        this.className = '_User';\n      } else {\n        this.className = className;\n      }\n    }\n\n    this._fields = {};\n    this._indexes = {};\n  }\n  /**\n   * Static method to get all schemas\n   *\n   * @return {Promise} A promise that is resolved with the result when\n   * the query completes.\n   */\n\n\n  (0, _createClass2.default)(ParseSchema, [{\n    key: \"get\",\n\n    /**\n     * Get the Schema from Parse\n     *\n     * @return {Promise} A promise that is resolved with the result when\n     * the query completes.\n     */\n    value: function () {\n      this.assertClassName();\n\n      var controller = _CoreManager.default.getSchemaController();\n\n      return controller.get(this.className).then(function (response) {\n        if (!response) {\n          throw new Error('Schema not found.');\n        }\n\n        return response;\n      });\n    }\n    /**\n     * Create a new Schema on Parse\n     *\n     * @return {Promise} A promise that is resolved with the result when\n     * the query completes.\n     */\n\n  }, {\n    key: \"save\",\n    value: function () {\n      this.assertClassName();\n\n      var controller = _CoreManager.default.getSchemaController();\n\n      var params = {\n        className: this.className,\n        fields: this._fields,\n        indexes: this._indexes,\n        classLevelPermissions: this._clp\n      };\n      return controller.create(this.className, params);\n    }\n    /**\n     * Update a Schema on Parse\n     *\n     * @return {Promise} A promise that is resolved with the result when\n     * the query completes.\n     */\n\n  }, {\n    key: \"update\",\n    value: function () {\n      this.assertClassName();\n\n      var controller = _CoreManager.default.getSchemaController();\n\n      var params = {\n        className: this.className,\n        fields: this._fields,\n        indexes: this._indexes,\n        classLevelPermissions: this._clp\n      };\n      this._fields = {};\n      this._indexes = {};\n      return controller.update(this.className, params);\n    }\n    /**\n     * Removing a Schema from Parse\n     * Can only be used on Schema without objects\n     *\n     * @return {Promise} A promise that is resolved with the result when\n     * the query completes.\n     */\n\n  }, {\n    key: \"delete\",\n    value: function () {\n      this.assertClassName();\n\n      var controller = _CoreManager.default.getSchemaController();\n\n      return controller.delete(this.className);\n    }\n    /**\n     * Removes all objects from a Schema (class) in Parse.\n     * EXERCISE CAUTION, running this will delete all objects for this schema and cannot be reversed\n     * @return {Promise} A promise that is resolved with the result when\n     * the query completes.\n     */\n\n  }, {\n    key: \"purge\",\n    value: function () {\n      this.assertClassName();\n\n      var controller = _CoreManager.default.getSchemaController();\n\n      return controller.purge(this.className);\n    }\n    /**\n     * Assert if ClassName has been filled\n     * @private\n     */\n\n  }, {\n    key: \"assertClassName\",\n    value: function () {\n      if (!this.className) {\n        throw new Error('You must set a Class Name before making any request.');\n      }\n    }\n    /**\n     * Sets Class Level Permissions when creating / updating a Schema.\n     * EXERCISE CAUTION, running this may override CLP for this schema and cannot be reversed\n     *\n     * @param {Object} clp Class Level Permissions\n     * @return {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"setCLP\",\n    value: function (clp\n    /*: { [key: string]: mixed }*/\n    ) {\n      this._clp = clp;\n      return this;\n    }\n    /**\n     * Adding a Field to Create / Update a Schema\n     *\n     * @param {String} name Name of the field that will be created on Parse\n     * @param {String} type Can be a (String|Number|Boolean|Date|Parse.File|Parse.GeoPoint|Array|Object|Pointer|Parse.Relation)\n     * @param {Object} options\n     * Valid options are:<ul>\n     *   <li>required: If field is not set, save operation fails (Requires Parse Server 3.7.0+)\n     *   <li>defaultValue: If field is not set, a default value is selected (Requires Parse Server 3.7.0+)\n     * </ul>\n     * @return {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"addField\",\n    value: function (name\n    /*: string*/\n    , type\n    /*: string*/\n    ) {\n      var options\n      /*: FieldOptions*/\n      = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      type = type || 'String';\n\n      if (!name) {\n        throw new Error('field name may not be null.');\n      }\n\n      if ((0, _indexOf.default)(FIELD_TYPES).call(FIELD_TYPES, type) === -1) {\n        throw new Error(\"\".concat(type, \" is not a valid type.\"));\n      }\n\n      var fieldOptions = {\n        type: type\n      };\n\n      if (typeof options.required === 'boolean') {\n        fieldOptions.required = options.required;\n      }\n\n      if (options.defaultValue !== undefined) {\n        fieldOptions.defaultValue = options.defaultValue;\n      }\n\n      this._fields[name] = fieldOptions;\n      return this;\n    }\n    /**\n     * Adding an Index to Create / Update a Schema\n     *\n     * @param {String} name Name of the field that will be created on Parse\n     * @param {String} type Can be a (String|Number|Boolean|Date|Parse.File|Parse.GeoPoint|Array|Object|Pointer|Parse.Relation)\n     * @return {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"addIndex\",\n    value: function (name\n    /*: string*/\n    , index\n    /*: any*/\n    ) {\n      if (!name) {\n        throw new Error('index name may not be null.');\n      }\n\n      if (!index) {\n        throw new Error('index may not be null.');\n      }\n\n      this._indexes[name] = index;\n      return this;\n    }\n    /**\n     * Adding String Field\n     *\n     * @param {String} name Name of the field that will be created on Parse\n     * @param {Object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n     * @return {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"addString\",\n    value: function (name\n    /*: string*/\n    , options\n    /*: FieldOptions*/\n    ) {\n      return this.addField(name, 'String', options);\n    }\n    /**\n     * Adding Number Field\n     *\n     * @param {String} name Name of the field that will be created on Parse\n     * @param {Object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n     * @return {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"addNumber\",\n    value: function (name\n    /*: string*/\n    , options\n    /*: FieldOptions*/\n    ) {\n      return this.addField(name, 'Number', options);\n    }\n    /**\n     * Adding Boolean Field\n     *\n     * @param {String} name Name of the field that will be created on Parse\n     * @param {Object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n     * @return {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"addBoolean\",\n    value: function (name\n    /*: string*/\n    , options\n    /*: FieldOptions*/\n    ) {\n      return this.addField(name, 'Boolean', options);\n    }\n    /**\n     * Adding Date Field\n     *\n     * @param {String} name Name of the field that will be created on Parse\n     * @param {Object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n     * @return {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"addDate\",\n    value: function (name\n    /*: string*/\n    , options\n    /*: FieldOptions*/\n    ) {\n      if (options && options.defaultValue) {\n        options.defaultValue = {\n          __type: 'Date',\n          iso: new Date(options.defaultValue)\n        };\n      }\n\n      return this.addField(name, 'Date', options);\n    }\n    /**\n     * Adding File Field\n     *\n     * @param {String} name Name of the field that will be created on Parse\n     * @param {Object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n     * @return {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"addFile\",\n    value: function (name\n    /*: string*/\n    , options\n    /*: FieldOptions*/\n    ) {\n      return this.addField(name, 'File', options);\n    }\n    /**\n     * Adding GeoPoint Field\n     *\n     * @param {String} name Name of the field that will be created on Parse\n     * @param {Object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n     * @return {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"addGeoPoint\",\n    value: function (name\n    /*: string*/\n    , options\n    /*: FieldOptions*/\n    ) {\n      return this.addField(name, 'GeoPoint', options);\n    }\n    /**\n     * Adding Polygon Field\n     *\n     * @param {String} name Name of the field that will be created on Parse\n     * @param {Object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n     * @return {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"addPolygon\",\n    value: function (name\n    /*: string*/\n    , options\n    /*: FieldOptions*/\n    ) {\n      return this.addField(name, 'Polygon', options);\n    }\n    /**\n     * Adding Array Field\n     *\n     * @param {String} name Name of the field that will be created on Parse\n     * @param {Object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n     * @return {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"addArray\",\n    value: function (name\n    /*: string*/\n    , options\n    /*: FieldOptions*/\n    ) {\n      return this.addField(name, 'Array', options);\n    }\n    /**\n     * Adding Object Field\n     *\n     * @param {String} name Name of the field that will be created on Parse\n     * @param {Object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n     * @return {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"addObject\",\n    value: function (name\n    /*: string*/\n    , options\n    /*: FieldOptions*/\n    ) {\n      return this.addField(name, 'Object', options);\n    }\n    /**\n     * Adding Pointer Field\n     *\n     * @param {String} name Name of the field that will be created on Parse\n     * @param {String} targetClass Name of the target Pointer Class\n     * @param {Object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n     * @return {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"addPointer\",\n    value: function (name\n    /*: string*/\n    , targetClass\n    /*: string*/\n    ) {\n      var options\n      /*: FieldOptions*/\n      = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      if (!name) {\n        throw new Error('field name may not be null.');\n      }\n\n      if (!targetClass) {\n        throw new Error('You need to set the targetClass of the Pointer.');\n      }\n\n      var fieldOptions = {\n        type: 'Pointer',\n        targetClass: targetClass\n      };\n\n      if (typeof options.required === 'boolean') {\n        fieldOptions.required = options.required;\n      }\n\n      if (options.defaultValue !== undefined) {\n        fieldOptions.defaultValue = options.defaultValue;\n\n        if (options.defaultValue instanceof _ParseObject.default) {\n          fieldOptions.defaultValue = options.defaultValue.toPointer();\n        }\n      }\n\n      this._fields[name] = fieldOptions;\n      return this;\n    }\n    /**\n     * Adding Relation Field\n     *\n     * @param {String} name Name of the field that will be created on Parse\n     * @param {String} targetClass Name of the target Pointer Class\n     * @return {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"addRelation\",\n    value: function (name\n    /*: string*/\n    , targetClass\n    /*: string*/\n    ) {\n      if (!name) {\n        throw new Error('field name may not be null.');\n      }\n\n      if (!targetClass) {\n        throw new Error('You need to set the targetClass of the Relation.');\n      }\n\n      this._fields[name] = {\n        type: 'Relation',\n        targetClass: targetClass\n      };\n      return this;\n    }\n    /**\n     * Deleting a Field to Update on a Schema\n     *\n     * @param {String} name Name of the field\n     * @return {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"deleteField\",\n    value: function (name\n    /*: string*/\n    ) {\n      this._fields[name] = {\n        __op: 'Delete'\n      };\n      return this;\n    }\n    /**\n     * Deleting an Index to Update on a Schema\n     *\n     * @param {String} name Name of the field\n     * @return {Parse.Schema} Returns the schema, so you can chain this call.\n     */\n\n  }, {\n    key: \"deleteIndex\",\n    value: function (name\n    /*: string*/\n    ) {\n      this._indexes[name] = {\n        __op: 'Delete'\n      };\n      return this;\n    }\n  }], [{\n    key: \"all\",\n    value: function () {\n      var controller = _CoreManager.default.getSchemaController();\n\n      return controller.get('').then(function (response) {\n        if (response.results.length === 0) {\n          throw new Error('Schema not found.');\n        }\n\n        return response.results;\n      });\n    }\n  }]);\n  return ParseSchema;\n}();\n\nvar DefaultController = {\n  send: function (className\n  /*: string*/\n  , method\n  /*: string*/\n  )\n  /*: Promise*/\n  {\n    var params\n    /*: any*/\n    = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    var RESTController = _CoreManager.default.getRESTController();\n\n    return RESTController.request(method, \"schemas/\".concat(className), params, {\n      useMasterKey: true\n    });\n  },\n  get: function (className\n  /*: string*/\n  )\n  /*: Promise*/\n  {\n    return this.send(className, 'GET');\n  },\n  create: function (className\n  /*: string*/\n  , params\n  /*: any*/\n  )\n  /*: Promise*/\n  {\n    return this.send(className, 'POST', params);\n  },\n  update: function (className\n  /*: string*/\n  , params\n  /*: any*/\n  )\n  /*: Promise*/\n  {\n    return this.send(className, 'PUT', params);\n  },\n  delete: function (className\n  /*: string*/\n  )\n  /*: Promise*/\n  {\n    return this.send(className, 'DELETE');\n  },\n  purge: function (className\n  /*: string*/\n  )\n  /*: Promise*/\n  {\n    var RESTController = _CoreManager.default.getRESTController();\n\n    return RESTController.request('DELETE', \"purge/\".concat(className), {}, {\n      useMasterKey: true\n    });\n  }\n};\n\n_CoreManager.default.setSchemaController(DefaultController);\n\nvar _default = ParseSchema;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}