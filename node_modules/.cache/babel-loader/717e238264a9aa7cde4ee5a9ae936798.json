{"ast":null,"code":"import Parse from 'parse';\nimport { Record } from 'immutable';\nimport { withState, withHandlers, pipe } from '../../util';\nconst ClouseQuery = Parse.Object.extend('ClouseQuery');\n\nconst init = props => props.filterData;\n\nconst addClouse = ({\n  setData,\n  data\n}) => () => {\n  const query = new Parse.Query(ClouseQuery);\n  const newd = { ...data\n  };\n  console.log('newd', newd);\n  newd.childs = newd.childs.concat(query);\n  setData(newd);\n};\n\nconst deleteChild = ({\n  setData,\n  data\n}) => index => {\n  const newd = { ...data\n  };\n  newd.childs = newd.childs.filter((value, i) => i !== index);\n  setData(newd);\n};\n\nconst changeOprand = ({\n  setData\n}) => oprand => {\n  setData(d => d.set('op', oprand));\n};\n\nconst addOprand = ({\n  setData,\n  data\n}) => () => {\n  const query = new Parse.Query(ClouseQuery);\n  const newd = { ...data\n  };\n  newd.childs = newd.childs.concat({\n    op: 'and',\n    childs: [],\n    mainQuery: query\n  });\n  setData(newd); // setData((d) => d.set('childs', d.childs.concat(Record({ op: 'and', childs: [], mainQuery: query })())));\n};\n\nconst makeMainQuery = ({\n  data\n}) => queryList => {\n  let mainQuery = new Parse.Query(ClouseQuery);\n\n  if (data.op === 'and') {\n    queryList.map(item => {\n      mainQuery = Parse.Query.and(mainQuery, item);\n    });\n  } else {\n    queryList.map(item => {\n      mainQuery = Parse.Query.or(mainQuery, item);\n    });\n  }\n\n  console.log('mainquery', mainQuery);\n  mainQuery.find().then(response => console.log('res', response));\n};\n\nconst addObject = () => () => {\n  const obj = new Parse.Object('ClouseQuery');\n  obj.set('name', 'rox');\n  obj.set('id', 1);\n  obj.save;\n};\n/*\nconst makeMainQuery = (data) => {\n  console.log('maake main query start', mainQuery);\n  console.log(data.mainQuery);\n\n  if (data.childs) {\n    const { op } = data;\n    data.childs.map((x) => {\n      if (op === 'and') {\n        data.mainQuery = Parse.Query.and(data.mainQuery, makeMainQuery(x));\n      }\n      if (op === 'or') {\n        console.log('op', data.op);\n        data.mainQuery = Parse.Query.or(data.mainQuery, makeMainQuery(x));\n      }\n      if (!x.op) {\n        if (op === 'and') {\n          console.log('op', op);\n          data.mainQuery = Parse.Query.and(data.mainQuery, x);\n        } else {\n          data.mainQuery = Parse.Query.or(data.mainQuery, x);\n        }\n      }\n      return makeMainQuery(x);\n    });\n  } else {\n    console.log('nochilds');\n    return data;\n  }\n};\n*/\n\n/*\nconst recursiveFunc = () => (n) => {\n  makeMainQuery(n);\n};\n*/\n\n\nconst oprandController = pipe(withState(init), withHandlers({\n  addClouse,\n  deleteChild,\n  changeOprand,\n  addOprand,\n  makeMainQuery,\n  addObject\n}));\nexport default oprandController;","map":{"version":3,"sources":["/home/roxana/React-Project/datafilter/src/components/oprand/oprandController.js"],"names":["Parse","Record","withState","withHandlers","pipe","ClouseQuery","Object","extend","init","props","filterData","addClouse","setData","data","query","Query","newd","console","log","childs","concat","deleteChild","index","filter","value","i","changeOprand","oprand","d","set","addOprand","op","mainQuery","makeMainQuery","queryList","map","item","and","or","find","then","response","addObject","obj","save","oprandController"],"mappings":"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","sourcesContent":["\nimport Parse from 'parse';\nimport {\n  Record,\n} from 'immutable';\nimport {\n  withState, withHandlers, pipe,\n} from '../../util';\n\n\nconst ClouseQuery = Parse.Object.extend('ClouseQuery');\n\nconst init = (props) => props.filterData;\n\nconst addClouse = ({ setData, data }) => () => {\n  const query = new Parse.Query(ClouseQuery);\n  const newd = { ...data };\n  console.log('newd', newd);\n  newd.childs = newd.childs.concat(query);\n  setData(newd);\n};\n\nconst deleteChild = ({ setData, data }) => (index) => {\n  const newd = { ...data };\n  newd.childs = newd.childs.filter((value, i) => i !== index);\n  setData(newd);\n};\n\nconst changeOprand = ({ setData }) => (oprand) => {\n  setData((d) => d.set('op', oprand));\n};\n\nconst addOprand = ({ setData, data }) => () => {\n  const query = new Parse.Query(ClouseQuery);\n  const newd = { ...data };\n  newd.childs = newd.childs.concat({ op: 'and', childs: [], mainQuery: query });\n  setData(newd);\n  // setData((d) => d.set('childs', d.childs.concat(Record({ op: 'and', childs: [], mainQuery: query })())));\n};\n\n\nconst makeMainQuery = ({ data }) => (queryList) => {\n  let mainQuery = new Parse.Query(ClouseQuery);\n  if (data.op === 'and') {\n    queryList.map((item) => {\n      mainQuery = Parse.Query.and(mainQuery, item);\n    });\n  } else {\n    queryList.map((item) => {\n      mainQuery = Parse.Query.or(mainQuery, item);\n    });\n  }\n  console.log('mainquery', mainQuery);\n  mainQuery.find().then((response) => console.log('res', response));\n};\n\nconst addObject = () => () => {\n  const obj = new Parse.Object('ClouseQuery');\n  obj.set('name', 'rox');\n  obj.set('id', 1);\n  obj.save;\n};\n\n/*\nconst makeMainQuery = (data) => {\n  console.log('maake main query start', mainQuery);\n  console.log(data.mainQuery);\n\n  if (data.childs) {\n    const { op } = data;\n    data.childs.map((x) => {\n      if (op === 'and') {\n        data.mainQuery = Parse.Query.and(data.mainQuery, makeMainQuery(x));\n      }\n      if (op === 'or') {\n        console.log('op', data.op);\n        data.mainQuery = Parse.Query.or(data.mainQuery, makeMainQuery(x));\n      }\n      if (!x.op) {\n        if (op === 'and') {\n          console.log('op', op);\n          data.mainQuery = Parse.Query.and(data.mainQuery, x);\n        } else {\n          data.mainQuery = Parse.Query.or(data.mainQuery, x);\n        }\n      }\n      return makeMainQuery(x);\n    });\n  } else {\n    console.log('nochilds');\n    return data;\n  }\n};\n*/\n\n/*\nconst recursiveFunc = () => (n) => {\n  makeMainQuery(n);\n};\n*/\n\nconst oprandController = pipe(\n  withState(init),\n  withHandlers({\n    addClouse,\n    deleteChild,\n    changeOprand,\n    addOprand,\n    makeMainQuery,\n    addObject,\n  }),\n);\n\nexport default oprandController;\n"]},"metadata":{},"sourceType":"module"}